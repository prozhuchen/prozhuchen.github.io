<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[c++ primer 笔记第十二弹 - 动态内存]]></title>
      <url>%2F2017%2F01%2F22%2Fc%2B%2Bprimer_note12%2F</url>
      <content type="text"><![CDATA[c++ primer中第十二章：动态内存的笔记。 内存类型分类 静态内存：静态内存用来保存局部static对象，类static数据成员，以及定义在任何函数之外的变量。 栈内存：用来保存在函数内的非static对象，由编译器进行自动创建和销毁。 堆内存：又称自由空间。是我们在程序运行时分配的对象。动态对象的生存期由程序来控制。所以需要我们显式的销毁。 直接管理内存 -new ，delete 如果new无法分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。 new的作用是分配所需内存，返回指向该对象的指针 delete的作用是销毁给定指针指向的对象，释放对应内存。 new是可以分配const对象的。 动态内存不同于之前的shared_str，他不会自动释放，所以它的生存期一直到被显式释放之前。但是在很多情况下，我们都容易忘记释放内存，导致内存泄露。 直接管理内存的劣势： 忘记delete内存。 使用已经释放过的对象。 同一块内存释放两次。 特别是我们有多个指针指向同一块内存，当其中一个指针delete后，其他指针指向的内存也没有了，此时所有指针无效了。但是我们容易忘记该事实。 智能指针智能指针是c++11新标准颁布的，用来管理动态内存。智能指针与以前的new，delete区别主要在于他可以自动释放所指向的对象。主要有两类智能指针：shared_ptr和unique_str。shared_ptr允许多个指针指向同一个对象，unique_str独占所指向的对象。 shared_ptrshared_ptr也是一种模板，定义时我们需要提供指针可以指向的类型： 12shared_ptr&lt;string&gt; p1; //可以指向string类型shared_ptr&lt;list&lt;int&gt;&gt; p2; //可以指向list&lt;int&gt;类型 shared_ptr分配内存shared_ptr使用make_shared标准库函数来分配内存。 123456// shared_ptr that points to an int with value 42shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);// p4 points to a string with value 9999999999shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, ’9’);// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;(); 注意一点，调用make_shared&lt;string&gt;时传递的参数必须与string的某个构造函数相匹配。如果不传递任何参数，对象会自己进行初始化。 我们也可以使用c++11新标准的auto关键字进行定义 1auto p6 = make_shared&lt;vector&lt;string&gt;&gt;(); shared_ptr拷贝与赋值当进行拷贝与赋值操作时，每个shared_ptr都会记录有多少个其他的shared_ptr指向相同的对象。 每一个shared_ptr都有一个关联的计数器。当我们拷贝一个shared_str时，计数器就会递增。 基本上一个例子我们就能明白。 12345auto r = make_shared&lt;int&gt;(42); // r指向的int只有一个引用者r = q; // r指向了q所指向的地址 // 递增q所指向对象的引用计数 // 递减r原来所指向对象的引用计数 // r原来所指向对象的引用计数为0，即没有引用者，自动释放 shared_str自动销毁所指对象shared_str是通过一个特殊的成员函数-析构函数来完成销毁工作的。如果当引用计数为0时，它的析构函数就会自动销毁对象，释放内存。 shared_str自定义删除器如果我们希望被销毁时，对指针不是单纯的进行delete操作，我们可以定义一个自己的删除器函数传给智能指针。 123456789void end_connection(connection *p) &#123; disconnect(*p); &#125;void f(destination &amp;d /* other parameters */)&#123;connection c = connect(&amp;d);shared_ptr&lt;connection&gt; p(&amp;c, end_connection);// use the connection// when f exits, even if by an exception, the connection will be properly closed&#125; 我们可以看到上面的例子，当p被销毁时，我们会调用end_connection，来确保链接被关闭。这样即使在代码运行中发生异常，由于智能指针的特质，连接也一定会被关闭。 unique_strunique_str与shared_str不同的是，某个时刻只能有一个unique_str指向一个给定对象。当unique_str被销毁时，它所指向的对象也会被销毁。 unique_ptr分配内存unique_str没有make_shared这样的标准库函数来返回动态指针。我们只能使用new进行直接初始化。 12unique_ptr&lt;double&gt; p1; unique_ptr&lt;int&gt; p2(new int(42)); unique_ptr拷贝与赋值因为unique_str绑定了他指向的对象，所以她不能进行普通的拷贝或者赋值。我们只能调用release或者reset来转移指针的所有权。 12345// transfers ownership from p1 (which points to the string Stegosaurus) to p2unique_ptr&lt;string&gt; p2(p1.release()); // release makes p1 nullunique_ptr&lt;string&gt; p3(new string("Trex"));// transfers ownership from p3 to p2p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed 我们可以发现，利用release将切断unique_ptr和他所绑定对象的关系，返回的值可以用来初始化另一个unique_ptr。这样就达到了所有权转移的目的。 unique_str自定义删除器unique_str自定义删除器和上面shared_str不同，我们必须在尖括号中unique_str指向类型后提供删除器类型。重写上面shared_str自定义删除器的例子： 12345678void f(destination &amp;d )&#123;connection c = connect(&amp;d); // 当p被销毁时，连接将会被关闭unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection);// 即使发生异常，连接也会被关闭&#125; 在这个例子中，decltype返回的是一个函数类型，所以我们必须添加一个* 来指出我们该类型的一个指针。 unique_str管理动态数组unique_str初始化动态数组的时候，我们要在对象类型后加一对空方括号。 123// up 指向一个包含10个非初始化int的数组unique_ptr&lt;int[]&gt; up(new int[10]);up.release(); // 自动调用delete[]销毁其指针 当一个unique_str指向一个数组时，我们可以使用下标运算符来访问数组中的元素。 12for (size_t i = 0; i != 10; ++i) up[i] = i; allocator类new操作将内存分配和对象构造结合在一起，delete将对象析构和内存释放组合在一起。但是有的时候，我们希望将内存分配和对象构造分离。我们可以先分配大块内存，然后再真正需要时才执行对象创建操作。 allocator分配内存allocator是一个模板，为了定义一个对象，我们要指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据对象类型来确定恰当的内存大小。但是这些内存是未构造的，所以我们需要的时候，要构造相应的对象。 12allocator&lt;string&gt; alloc; auto const p = alloc.allocate(n); // 分配n个未初始化的string allocator构造对象我们可以使用construct来在未分配的内存初始化构造的对象。 1234auto q = p; // q 指向最后构造的元素之后的位置alloc.construct(q++); // *q is the empty stringalloc.construct(q++, 10, ’c’); // *q is ccccccccccalloc.construct(q++, "hi"); // *q is hi! allocator销毁对象当我们用完对象后，我们需要销毁这个对象，对指向的对象执行析构函数。 12while (q != p) alloc.destroy(--q); 我们需要用一个while循环，来不停的销毁对象，并且对q进行递减操作。这样能够保证所有构造元素都被销毁。销毁后，我们可以重新使用这部分内存来保存其他的string。 allocator销毁内存1alloc.deallocate(p, n); 我们传递给该函数的指针不能为空，必须指向由allocate分配的内存。而且传递给deallocate的大小参数必须和allocate分配内存时的大小一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ primer 笔记第七弹 - 类]]></title>
      <url>%2F2017%2F01%2F19%2Fc%2B%2Bprimer_note7%2F</url>
      <content type="text"><![CDATA[c++ primer中第七章：类的笔记。 类中的this指针在类中this是一个隐式参数，指向调用他的那个对象。因为this的目的是指向对象，所以this是一个常量指针，不能修改this中保存的地址。 在默认情况下，this是一个指向非常量的常量指针。例如类是sale_data,this指针的类型为sale_data *const。之前书上提到过，常量指针是不能绑定常量对象上的。例如： 1234int p1 = 1;const int p2 = 2;int *const a1 = &amp;p1; // rightint *const a2 = &amp;p2; // wrong 所以如果想函数内部不改变对象的内容，则在函数后面加上const。例如：1234string isbn() const&#123; return bookNo;&#125; c++11新标准-默认构造函数default当我们的类需要一个默认的构造函数时，我们可以使用如下的句式为类sale_data要求一个编译器自动生成的构造函数。1Sales_data() = default; 如果上述句式出现在类内，默认构造函数是内联的。如果出现在类外，则不是内联的。 定义类 - class和struct使用class和struct定义类的唯一区别就是默认访问权限不同。class默认是private，struct默认是public。 可变数据成员 - mutable如果在某种情况下，你希望即使在一个const函数内，也要修改某个数据成员，你就在这个数据成员的声明前加上mutable关键字。12345678910class Screen &#123;public:void some_member() const;private:mutable size_t access_ctr; &#125;;void Screen::some_member() const&#123;++access_ctr; &#125; 上述例子中，即使some_member函数是一个const函数，我们也可以修改access_ctr的值。 返回*this的成员函数123456789101112131415class Screen &#123;public:Screen &amp;set(char);Screen &amp;display() const;&#125;;inline Screen &amp;Screen::set(char c)&#123;......return *this; &#125;Screen &amp;Screen::display() const&#123;......return *this; &#125; 根据上述例子，set函数返回的是调用set的对象的引用，这样我们可以将一系列操作链接成一句表达式。1myScreen.set('1').set('2') 我们可以看到这个表达式等价于：12myScreen.set('1');myScreen.set('2'); 如果返回的是screen而不是screen&amp;，我们只能在*this上的拷贝副本进行set(&#39;2&#39;)，等价于：12Screen temp = myScreen.set('1');temp.set('2'); 而此时如果使用的是display函数，由于它是常量函数，所以返回的应该是const Screen&amp;，这时候下面的句子会出现问题。1myScreen.display().set('2') 因为此时display返回的是常量引用，而set无权对此操作。 ## 友元 友元类可以访问该类中的非公有成员，只需要在友元类声明的前面加上friend。 友元关系没有传递性，友元类的友元类不能也可以访问该类中的非公有成员。 ## 成员初始化的顺序 成员的初始化顺序与他们在类定义中的出现顺序一致，而与在构造函数的初始化列表顺序无关。 聚合类和字面值常量类聚合类有如下特征： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值 没有基类没，没有virtual函数。 字面值常量类 数据成员全是字面值类型。 至少含有一个constexpr构造函数。 类必须使用析构函数的默认定义。 如果一个数据成员含有类内初始值，则初始值必须是一条常量表达式。如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 静态static成员 静态成员不与任何对象绑定在一起，它属于整个类。 静态成员不包含this指针。 静态成员不能声明成const的。 不能在静态函数内使用this指针。 静态成员必须在类的外部定义和初始化。 静态成员与非静态的一些试用场景区别： 静态成员可以被类函数当做默认实参，而非静态成员不可以。因为非静态成员的值本身就属于对象的一部分。 静态成员的类型可以是他所属类的类型，但是非静态成员不可以。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[调整youtube播放速度]]></title>
      <url>%2F2017%2F01%2F10%2Fslowdownyoutube%2F</url>
      <content type="text"><![CDATA[在youtube看英文视频时，语速太快听不懂啊，今天突然发现了一个在线自定义播放速度的方法。 在播放视频界面点击F12调出开发者界面。 在console栏输入1document.getElementsByTagName("video") [0].playbackRate = 0.5 此时播放速度就是0.5倍啦，你想调成0.1都可以。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网站改动-加入背景特效 & 自定义页面存放特定文章]]></title>
      <url>%2F2017%2F01%2F05%2Fweb_change%2F</url>
      <content type="text"><![CDATA[今天突然发现next主题更新了好多东西，所以将自己网站的主题升级了，版本从0.4.5.1升到了5.1.0，并且做了一些改动。 不是主题提供的改动如下： 1. 加入了背景特效这个主要是借鉴了这位博主的博客 传送门，觉得这样的背景特效很炫。所以也在自己的博客里加入。这位博主也有文章提到了如何加入该特效，我在这里只说明我的做法。 1.1 特效文件保存本地该特效是来自这个js文件提供的 传送门。由于害怕未来这个地址失效，所以我们可以保存在本地。 在我们的next\source\js\src下，添加文件canvas-nest.min.js，将上述地址的内容拷贝进去。 1.2 特效文件集成进next 打开next\layout\_layout.swig，在之前添加如下代码（这点几乎完全是借鉴那个博主的）： 123&#123;% if theme.canvas_nest %&#125; &lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/canvas-nest.min.js"&gt;&lt;/script&gt; &#123;% endif %&#125; 打开\next\_config.yml，加入下面的代码： 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 此时我们在重新部署打开，就能看到最终效果啦。 2. 将主题背景变透明加入了特效后，发现很多部分都被白色内容挡住了，把他们都移走！ 打开next\source\css\_schemes\Pisces\_layout.styl（这里你要是其他的主题，就把地址里的Pisces换成对应主题名） 找到123456789.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-desktop; background: white; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; 将background: white;去掉，加入如下内容：12345background:rgba(255, 255, 255, 0) none repeat scroll 0 0 !important;background-color:#000000;filter:Alpha(opacity=50);position:static; *zoom:1; 此时的主页就变成了： 3. 自定义页面存放特定文章因为我想在未来将一些读过的书的笔记单列成一项，对于读者也方便寻找，所以我自定义了读书笔记页面，里面只显示类别为读书笔记的文章。而且几乎所有的单独类别文章都可以这样列到首页啦。 3.1 定义文章类别这个只需要对新文章头部的categories部分进行填写即可，例如我希望将来显示读书笔记，这里就可以定义某一篇文章：12categories:- 读书笔记 3.2 配置首页归档在我们的\next\_config.yml下的memu项，加入对读书笔记项的配置：1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags readnotes: /categories/读书笔记/ 3.3 正确显示自定义项我们可以发现，经过上面的定义，我们的首页项多了一个，但是不是正确的中文显示，所以我们需要配置对应中文的显示。 打开next\languageszh-Hans.yml。 在memu项下新加对于自定义页面的定义，这里我加入：1readnotes: 读书笔记 重新部署，我们发现显示正确啦，举一反三，以后自己的感想之类的都可以单独列出来啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016CCF大赛-搜狗用户画像-经验分享]]></title>
      <url>%2F2016%2F12%2F28%2Fsummary_of_CCF%2F</url>
      <content type="text"><![CDATA[CCF大赛做了两个多月终于结束了，最后能拿到第五的成绩很意外也很高兴，毕竟第一次参加这种高规格的数据挖掘大赛，自己收获了很多。 在听取完前几名，包括其他比赛的答辩后，发现现在真是一个深度学习的时代。不管是在图像文本和其他领域，深度学习都表现出了比传统方法好很多的效果。队友戏言，我们是在没有用深度学习的团队中做的最好的，也算是对我们的一点安慰。 在这里对自己的之前两个月的成果做一点总结和思考吧。鉴于队友的博客 传送门 对于我们的整体模型已经讲得差不多了。这里对其算是一个补充和自己的一点感受吧，尽量不让大家感觉重复。 1. 算法描述本题目提供用户历史一个月的查询词与用户的人口属性标签（包括性别、年龄、学历）做为训练数据，要求参赛人员通过机器学习、数据挖掘技术构建分类算法来对新增用户的人口属性进行判定。其中性别是二分类问题，年龄和学历都是六分类问题。数据集复赛为10w条数据。 2. 整体流程概述2.1 特征工程2.1.1 分词 分词我们使用的是jieba分词包，从分词速度到精度都还不错。个人感觉想提高分词精度，一个好的自定义词典更加重要。 分词后处理部分，我们对停用词和单词的词性进行了过滤，只留下名词和动词。也是为了达到一种降维的目的吧。 最后的第一名大神考虑到了一点，他在分词时，保留了查询词条中的空格信息。他分析后认为博士词条空格数明显更多，是因为高学历者对于搜索引擎的使用更加熟练。这一点也得到了评委们的认可，在工业界的确也是这样处理的。 2.1.2 特征权重文本分类的一个经典模型就是VSM模型。其中词-文档矩阵使用的特征权重就是TFIDF。我们在TFIDF中加入了类间差异信息，改进出了一个基于布尔模型的S-TFIWF算法。细节大家可以看这里 传送门 。 对于TFIDF的不足，在前几名中都没有对其进行改变。这算是我们的一点亮点。其实在国内外不少论文中，都有很多对于TFIDF的改进，所以大家在做文本分类的时候，也可以试着去使用一些改进的特征权重算法，或者使用我们的这个O(∩_∩)O~。 2.1.3 特征选择这里是我们本次比赛中可以算是最为纠结的的一点。尝试了多种特征选择算法，但是最后发现还是利用单词出现频率出现效果最好，这一点我们很惆怅。本来想在决赛中看看其他队伍的特征选择情况。然而他们是选择了融入其他种类特征，或者直接走深度学习。几乎没有做特征选择。所以，还是深度学习大法好啊。 2.1.4 融入其他特征在nlp领域，有两个很著名的特征：LDA和词向量(word2vec，doc2vec)。这两个特征同样可以表达出文本的特征信息，甚至比起TFIDF更好。详细的介绍大家可以百度一波。 在我们的使用中，我们是讲训练好的word2vec信息融入到了后来提到的分类模型中。在前几名的答辩中，都是同时使用了这两个特征，分别或者一起放到深度学习框架里进行训练。然后和正常的TFIDF特征一起进行集成学习。这点是我们差距很大的地方。 同时在后来和高君老师的聊天中，他也提到了目前搜狗的做法也是利用词向量特征直接放到深度学习框架中来做。不同的是，他们拥有着十分庞大的数据量，所以效果更加显著。 2.2 分类模型我们在比赛中最后使用的集成模型是stacking模型。这里详细介绍一下这个模型，算是对队友的一个补充。 经典Stacking模型是指将多种分类器组合在一起来取得更好表现的一种集成学习模型。一般情况下，Stacking模型分为两层。第一层中我们训练多个不同的模型，然后再以第一层训练的各个模型的输出作为输入来训练第二层的模型，以得到一个最终的输出。为了更加详细的阐述stacking模型的训练和预测过程，我们用下面的图作为示例。首先，我们从stacking模型的训练开始阐述。在上图中我们可以看到，该模型的第一层有五个分类模型，第二层有一个分类模型。在第一层中，对于不同的分类模型，我们分别将训练数据分为 5 份，接下来迭代5次。每次迭代时，将 4 份数据作为训练集对每个分类模型进行训练，然后剩下一份数据在训练好的分类模型上进行预测并且保留结果。当5次迭代都完成以后，我们就获得了一个结果矩阵。该矩阵是一个N1的矩阵，N是训练集的样本数。当5个模型都进行完上述操作后，我们就可以得到一个N5的结果矩阵。然后将该矩阵导入到第二层的模型6中进行训练，此时全部模型训练完毕。接下来是stacking模型的预测过程。接下来我们开始阐述该模型的预测过程。在第一层中，对于不同分类模型，我们还是使用在训练时分成的5份训练数据进行五次迭代。每次迭代时，我们利用训练后的分类模型对预测集进行预测并保留下来。当5次迭代都完成以后，我们可以得到一个M5的矩阵，M是预测集的样本数。 我们将这个矩阵按列取平均，缩减成M1的矩阵。当5个模型都进行完上述操作后，我们就可以得到一个M*5的结果矩阵。然后将该矩阵导入到第二层中训练好的模型6进行预测，就可以得到最终的预测结果。 在介绍完经典stacking模型的训练及预测过程后，接下来阐述我们自己的stacking模型构建和改进。在模型训练过程中，模型第一层中的分类模型有25个。这其中包含了不同类型的分类器，和同一类型但是参数不同的分类器。增加这些分类器的原因是为了增加训练扰动，能够缓解分类模型的过拟合问题。在第二层中，我们使用了SVM分类器。同时我们加入了由词向量转变而成的文档向量矩阵，与第一层的训练结果进行特征拼接，拼接后的结果用来进行训练。加入词向量特征，可以引入词向量所含的语义信息。之所以加在第二层是因为第一层训练集特征的稀疏特性不适合与具有密集特性的词向量进行融合。在预测过程中，流程和训练过程相似，只是改成了用预测集在训练好的分类模型上进行预测。我们注意到，在Stacking模型中，由于在第一层的预测过程也需要使用第一层时的数据划分，所以一般Stacking模型的运行顺序是： 第一层训练 第一层预测 第二层训练 第二层预测 至此，我们改进后的stacking模型介绍完毕。 下面谈一下自己使用过程中的感受吧。 在sklearn中也是有集成模型的。但是他只有boosting和bagging的集成模型代码。可能还是因为stacking模型的灵活性太高了吧。 我们在第一层的模型选择上，主要是考虑到了速度问题，所以选取的都是一些线性分类器和速度比较快的线性核svm等。第二层我们使用的是rbf核SVM。但是在第二层的特征数由于加入了词向量特征而变大后，第二层的训练预测时间变得很长。所以SVM好，但是使用需谨慎啊。 对于xgboost模型，我们在和svm比较后，发现比不过svm分类器。同时xgboost的调参也是一个蛮长的贪心过程。所以我们没有使用xgboost。但是在答辩中，前几名的大神在集成模型上几乎都用到了xgboost。这也说明xgboost的效果还是非常好的。 stacking模型理论上可以扩大到无数层。但是在答辩过程中，发现大家都是只使用了两层，同时我们也实验了搭出三层的stacking，效果也不如两层的。 在一开始的时候，我们只在第一层中放入了四个分类器，但是受到了一些博客的影响，我们开始尝试加入更多的分类器。第一种是不同类型的分类器，但是更多的是同类型，但是不同参数下的分类器。我们发现，分类器越多时，最终效果更好。但是随着分类器的增多，效果提升的越来越少。但是这不失为是一个刷分的好方法。 3. 赛后总结 在比赛过程中，我们发现，想做到前50，就去多看大神博客。但是想做到前5，还是需要阅读一些这方面的论文进行思想上面的补充的。 由于我们做的是文本方面的问题，还有看到了一些图像方面的问题。深度学习都已经是主流的解决方法。但是我们也看到在一些传统的以特征工程为主的问题解决中，还是有不少都是利用传统的数据挖掘算法进行解决的。所以不能盲目迷信深度学习，也是要分情况讨论的。 不管在什么问题上，对于数据的分析都是十分重要的。这也是评委老师们十分看重的一点。毕竟大家的整体模型不会有很大差距，差距的所在很多情况下都是在对数据的分析上。 如果你是一个比赛小白，还是需要找一个靠谱的团队，不论是从哪个方面都能帮助你很多。当然也是有很多solo大神，这里只能膜拜了。 一个小建议：如果你答辩紧张，可以事先背演讲稿O(∩_∩)O哈哈~，亲测有用。 4. 代码代码和答辩PPT已经公开 传送门。在coding的过程中，也阅读了一些源码，发现自己的代码写的还是比较low的。在接下来有时间我准备把分类模型stacking这块的代码重构一下，尽量能够达到可复用的目标吧。 这里给大家一些自己的看法： 尽量能让自己的代码达到模块化，不管在后期修改和阅读中都有很大好处。在这里我们吃了很大的亏。 多阅读一些比较著名的源码。真的会对我们有很大帮助。 python数据挖掘包集合总结： 基础包：numpy,scipy 大神级数据挖掘包：sklearn 数据可视化：pandas 数据不均衡：imbalanced-learn 大神级nlp包：gensim（word2vec和LDA） 深度学习包：TensorFlow]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[STL源码剖析之第二章：空间配置器]]></title>
      <url>%2F2016%2F08%2F26%2FChapter_2_of_STL%2F</url>
      <content type="text"><![CDATA[1. 空间配置器 空间配置器：是对空间进行分配和处理的部分。是空间而不是内存的原因是因为空间也可以是磁盘等其他介质。 SGI STL的配置器是alloc而不是allocator，而且不接受任何参数。 SGI STL对于标准的配置器只做了一层简单包装，且不推荐我们使用。 在一般使用类的动态内存申请时，我们使用的new和delete其实都分为两步： new首先调用operator new 配置内存 new然后调用类的构造函数构造对象。 delete首先调用类的析构函数析构对象。 delete然后调用operator delete 释放内存 SGI STL的new和delete： 内存配置由alloc::allocate()负责。 内存释放由alloc::deallocate()负责。 对象构造由::construct()负责。 对象析构由::destroy()负责。 1.1 构造和析构：construct,destroy 1.2 空间的配置和释放::allocSGI对于空间配置的设计哲学如下： 向system heap要求空间 考虑多线程 考虑内存不足时的应变措施 考虑小区块带来的内存碎片问题 考虑到小区快带来的内存破碎问题，SGI设计了双层级配置器。 第一级配置器：直接使用C中的malloc和free。 第二级配置器：视情况不同，配置区块大于128byte时，调用第一级；小于128byte，采用更复杂的内存池 模式。 1.3 第一级配置器剖析 SGI其实是直接使用了c中的malloc和free。 SGI不使用c++的new,而是使用c的malloc,有一部分原因是因为c++中没有提供realloc的功能。 但是当出现内存配置出现问题时，SGI又会仿照C ++ 实现一个new-handler机制。不能直接使用c++的该机制的原因是，它没有使用new来配置内存，所以无法直接使用这个c ++ 的特定机制，只能仿真一个类似的。 当第一级配置器的allocate（）和realloc（）不成功时，它会调用oom_malloc（）和oom_realloc（）函数（oom代表out of memory），这两个函数内部都是一个内循环，不断调用“内存不足处理例程”。 注意一点的是，上述的内存不足处理例程由调用者自己设计，如果没有被设定，配置器会直接丢出BAD_AALOC异常。 1.4 第二级配置器剖析第二级配置器的存在就是为了解决小区块内存带来的内存碎片化和配置时带来的额外负担。 额外负担是指，当每一个区块内存被分配的时侯，他都需要一部分额外内存来纪录该块内存的大小，这一块纪录内存属于额外负担。 第二级配置器对于内存配置的做法是：区块大于128byte时，移交给第一级配置器处理。区块小于128byte时，使用内存池进行管理。 1.4.1 内存池管理内存池每次的配置一大块内存，然后用一个freelist来进行维护。有内存需求则从freelist拨出，如果释放则有freelist收回。为了方便管理，SGI会将小区块的内存需求调整到8的倍数。这样一来，有8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128，总共16个freelist。 上调到8的倍数实现： 12 enum &#123;__ALIGN=8&#125;;&#123; return (((__bytes) + (size_t) _ALIGN-1) &amp; ~((size_t) _ALIGN – 1)); &#125; free_list:为了节省空间，obj的结构是一个union类型。也就是说，当该区块给用户的时候，obj是一个指向实际区块的指针，当给系统时候，obj是一个指向下一个节点的指针。这个可以节省内存的开销。1234union obj&#123; union obj* free_list_link; char client_data[1];&#125; 1.4.2 空间配置函数allocate()区块大于128byte时，移交给第一级配置器处理。区块小于128byte时，在freelist中找可用区块，有则调用；没有则上调至8倍数边界，调用refill()来填充空间。 1.4.3 空间释放函数deellocate()区块大于128byte时，移交给第一级配置器处理。区块小于128byte时，找出对应区块，进行回收。 1.4.4 重新填充free_list函数refill()当allocate()发现没有freelist没有区块的时候，就调用refill()，refill()从内存池中取出内存重新填充freelist。默认取得20个新区快，但是当内存池不够时，获得的会小于20. 1.4.5 从内存池取内存函数chunk_alloc()chunk_alloc()通过两个指针：end_free和start_free的差值来判断内存池的剩下空间。 空间&gt;20区块空间：调出20个区块空间给freelist. 1区块空间&lt;空间&lt;20区块空间：调出能调出的空间出来。 空间&lt;1区块空间：使用malloc()从系统中申请内存，然后拨给freelist。新申请的量是需求量的两倍，加上一个随着配置次数增加不断变大的附加量。 特殊情况（系统内存不够，malloc失败）：chunk_alloc()开始寻找freelist中未被使用的够大的区块，找到了就拿走一块；找不到就调用第一级配置器。第一级配置器虽然使用也是malloc，但是有out-of-memory机制，可以有机会释放其他内存来使用。 1.5 内存基本处理工具对于未初始化的空间，STL的处理工具有五个：construct(),destroy(),uninitialized_copy(),uninitialized_fill(),uninitialized_fill_n()其中uninitialized_copy(),uninitialized_fill(),uninitialized_fill_n()分别对应STL算法中的copy() ,fill(),fil_n()。C++规格要求这三个函数具有commit or rollback语意。意思是要么就构造出所有必要元素。要么不构造任何东西。（很像数据库中的原子性） 1.5.1 uninitialized_copy()12template&lt;class InputIterator, class ForwardIterator&gt;ForwardIterator uninitialized_copy ( InputIterator first, InputIterator last,ForwardIterator result ) 该函数将[first，last)的值复制到[result，result+(last-first))。该函数在容器上的作用：容器的构造函数通常以两个步骤完成： 配置复制所需的内存区块。 使用uninitialized_copy()，在该内存区块上构造元素。 1.5.2 uninitialized_fill()12template &lt;class ForwardIterator, class T&gt; void uninitialized_fill (ForwardIterator first, ForwardIterator last, const T&amp; x); 如果[first，last)范围内的迭代器都指向未初始化的内存，那么该函数将会在该范围内产生x的复制品。 1.5.3 uninitialized_fill_n()12template &lt;class ForwardIterator, class Size, class T&gt; ForwardIterator uninitialized_fill_n (ForwardIterator first, Size n, const T&amp; x); 如果[first，first+n)范围内的迭代器都指向未初始化的内存，那么该函数将会在该范围内产生x的复制品。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客小知识：更改背景颜色]]></title>
      <url>%2F2016%2F07%2F10%2FHexo_blog_Tip%2F</url>
      <content type="text"><![CDATA[最近发现有读者在问这个博客的背景颜色是怎么做出来的，这里单独写出来解答一下吧。 更改背景颜色这种的事情是通过css来控制的，具体的文件是hexo/public/css下的main.css来定义的。下面是页面上两处颜色的定义。 12345678/*首页头部的颜色设置*/.header &#123; background: #d1fab8;&#125;/*主体部分的颜色设置*/body &#123; background: #e0fccf;&#125; 我们只需要更改上述的两个背景颜色，就可以获得我们想要的颜色效果。那如何获得我们想要的颜色代码呢？最简单的一种方法就是使用chrome上的颜色抓取器。或者可以参照RGB颜色查询对照表。 其实只要我们懂得简单的css和js，我们就可以更改任何我们想更改的部分啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[opencv小练习：哈尔小波(haar)]]></title>
      <url>%2F2016%2F07%2F07%2Fopencv_haar%2F</url>
      <content type="text"><![CDATA[首先说一下一维haar小波的原理。例如我们有一个一维的图像[2,4,6,8,10,12,14,16]. 求均值：我们求相邻像素的均值[3,7,11,15]。这个新的图像分辨率就成了原来的一半(8/2=4)。 求差值。上面的均值我们存储了图像的整体信息。但是很多细节信息我们丢掉了，所以我们同时要记录图像的细节信息，这样在重构时能够恢复图像的全部信息。下面是求第m个差值的公式： $$b[m]=(a[2m]-a[2m+1])/2$$经过计算我们得到了结果[-1,-1,-1,-1]。这个新的分辨率也成了原来的一半(8/2=4)。 此时上面两步形成了第一次分解的结果[3,7,11,15,-1,-1,-1,-1]。包含了图像的整体信息和细节信息。接下来的分解我们重复1,2步，将整体信息再次进行分解，得到了二级分解结果[5，13，-2，-2].同样的，前面的[5,13]是整体信息，后面的[-2,-2]是细节信息。 分辨率 整体信息 细节信息 4 3,7,11,15 -1,-1,-1,-1 2 5，13 -2，-2 1 9 -4 经过三次分解，我们得到了一个整体信息和三个细节系数，这个就是一维小波变换。 对于二维haar小波，我们通常一次分解形成了整体图像，水平细节，垂直细节，对角细节。首先我们按照一维haar小波分解的原理，按照行顺序对行进行处理，然后按照列顺序对行处理结果进行同样的处理。最后形成了如下的形式。 cpp代码（opencv版本：opencv3.0）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*************************************************Copyright:zhuchenAuthor: zhuchenDate:2016-01-10Description:多级haar小波变换**************************************************/# include&lt;opencv2/opencv.hpp&gt;# include&lt;iostream&gt;using namespace std;using namespace cv;int main()&#123; Mat img = imread("lenna.bmp",0); int Height = img.cols; int Width = img.rows; int depth = 3; //定义分解深度 int depthcount = 1; Mat tmp = Mat::ones(Width, Height, CV_32FC1); Mat wavelet = Mat::ones(Width, Height, CV_32FC1); Mat imgtmp = img.clone(); imgtmp.convertTo(imgtmp, CV_32FC1); while (depthcount&lt;=depth)&#123; Width = img.rows / depthcount; Height = img.cols / depthcount; int step = 2 * depthcount; for (int i = 0; i &lt; Width; i++)&#123; for (int j = 0; j &lt; Height / 2; j++)&#123; tmp.at&lt;float&gt;(i, j) = (imgtmp.at&lt;float&gt;(i, 2 * j) + imgtmp.at&lt;float&gt;(i, 2 * j + 1)) / 2; tmp.at&lt;float&gt;(i, j + Height / 2) = (imgtmp.at&lt;float&gt;(i, 2 * j) - imgtmp.at&lt;float&gt;(i, 2 * j + 1)) / 2; &#125; &#125; for (int i = 0; i &lt; Width / 2; i++)&#123; for (int j = 0; j &lt; Height; j++)&#123; wavelet.at&lt;float&gt;(i, j) = (tmp.at&lt;float&gt;(2 * i, j) + tmp.at&lt;float&gt;(2 * i + 1, j)) / 2; wavelet.at&lt;float&gt;(i + Width / 2, j) = (tmp.at&lt;float&gt;(2 * i, j) - tmp.at&lt;float&gt;(2 * i + 1, j)) / 2; &#125; &#125; imgtmp = wavelet; depthcount++; &#125; namedWindow("jpg",0); wavelet.convertTo(wavelet, CV_8UC1); wavelet += 50; //图像暗度过低，所以这里我加了50 imshow("jpg", wavelet); waitKey(0); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux读书笔记(1)]]></title>
      <url>%2F2016%2F04%2F14%2FLinux_Reading_Notes(1)%2F</url>
      <content type="text"><![CDATA[这篇文章主要讲的是linux的文件和目录方面的。 1. 用户和用户组每一个文件属于一个用户，而每一个用户会属于一个或多个用户组，而系统内会有多个用户组。有些文件用户组之间可以共享，而有些文件被设置成用户个人文件，即使是用户组内的其他用户也不能去读或写。这样的设置使linux下的多任务管理更加简单。在我们的linux系统下，默认所有用户和root的相关信息都记录在了/etc/passwd里面。个人的密码记录在/etc/shadow里，而linux内所有的组名都记录在/etc/group内。 2. linux的文件属性和权限linux下的文件构造可以通过ls -al查看，-a是指所有的文件（包括隐藏文件），-l是指文件信息会以列表格式展现出来。12345678910111213~$ ls -aldrwxr-xr-x 32 zhuchen root 4096 4月 14 18:04 .drwxr-xr-x 5 root root 4096 3月 16 10:50 ..drwx------ 3 zhuchen root 4096 3月 15 09:49 .adobe-rw-r--r-- 1 zhuchen root 25283 7月 17 2015 ascii_dora.png-rw------- 1 zhuchen zhuchen 13641 4月 14 17:19 .bash_history-rw-r--r-- 1 zhuchen root 220 3月 14 17:34 .bash_logout-rw-r--r-- 1 zhuchen root 3771 3月 14 17:34 .bashrcdrwxr-xr-x 20 zhuchen root 4096 3月 30 15:16 .cachedrwx------ 26 zhuchen root 4096 4月 7 18:17 .configdrwx------ 3 zhuchen root 4096 3月 14 19:26 .dbusdrwxr-xr-x 2 zhuchen root 4096 3月 23 15:29 Desktop 首先解读一下每列字段的意义。第一列代表这个文件的类型和权限。具体含义我们后面再说。第二列代表有多少文件名连接到此节点（i-node）。第三列代表文件（目录）所有者（用户）的账号。第四列代表文件（目录）所属的用户组。第五列代表文件（目录）的大小，默认单位为B。第六列代表文件（目录）的修改日期（未修改过则是创建日期）。第七列代表文件（目录）的名字。 下面我们重点解读一下第一列字符串，文件权限和类型的含义。以drwxr-xr-x为例子。第一个字符代表这个是目录，文件还是别的。 [d]：目录 [-]: 文件 [|]: 连接文件（linkfile） [b]: 设备文件里可供存储的接口设备。 [c]：设备文件里的串行接口设备（键盘，鼠标）。 例子中的第一个字符是d，也就是文件。 后面的字符每三个一组总共三组。第一组为’文件所有者的权限’，第二组为’一个用户组内其他用户的权限’，第三组为’不同用户组的用户的权限’。而每一组里有三个字符，第一个r代表可读，第二个w代表可写，第三个x代表可执行。这三个权限的位置不会改变，当没有这个权限的时候，该位置用-表示。例子中的rwxr-xr-x分为三组： 第一组rwx说明文件所有者对该文件可读，可写，可执行。 第二组r-x说明同用户组内其他用户对该文件可读，不可写，可执行。 第三组r-x说明不同用户组的其他用户对该文件可读，不可写，可执行。 3. 改变文件的属性和权限chgrp:改变文件用户组chown:改变文件所有者chmod:改变文件权限 linux每个文件的基本权限有九个，分别是owner，group，other三种身份各有自己的三个权限（rwx）。而这9个权限是三个一组的。其中，我们用数字来代表各个权限。r:4，w:2，x:1。我们这里拿rwxrw-r-x举例owner = rwx = 4+2+1 = 7group = rw- = 4+2+0 = 6other = r-x = 4+0+1 = 5 所以我们可以看出，如果要是想将这个文件的权限改为-rw-r--r--，就可以用 chmod 644 filename。 4.权限对于文件和目录的作用文件： r:可以读取文件的实际内容。w:可以编辑，新增和修改内容，但是不能删除。x:可以被系统执行的权限。至于w权限为什么不可以删除该文件，是因为这里的rwx权限都是对于文件本身的内容来说的，而不是文件的存在。 目录： r:可以读取该目录结构列表的权限。也就是可以用ls这个命令了。w:表示你可以更改该目录结构的权限。即： 新建新的文件和目录 删除存在的文件和目录 重命名存在的文件和目录 转移存在的文件和目录 x:表示用户能否进入该目录成为工作目录的权限。所谓的工作目录就是你目前所做的目录。也就是你能用cd将转变目前的工作目录成该目录的权限。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib更改字体以及支持中文问题]]></title>
      <url>%2F2016%2F02%2F20%2Fmatplotlib_question%2F</url>
      <content type="text"><![CDATA[在使用matplotlib的时候，发现了matplotlib无法支持中文的一个问题。 123456789import matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8]y = [1,2,3,4,5,6,7,8]plt.plot(x, y)plt.title(u'测试程序')plt.xlabel(u'x轴')plt.ylabel(u'y轴')plt.grid(True)plt.show() 结果图： 有两个方法解决他： 直接在开头时改变整个脚本的显示字体：matplotlib.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;] 当然这个SimHei是可以自己改的。 例子：12345678910import matplotlib.pyplot as pltmatplotlib.rcParams['font.sans-serif'] = ['SimHei']x = [1,2,3,4,5,6,7,8]y = [1,2,3,4,5,6,7,8]plt.plot(x, y)plt.title(u'测试程序')plt.xlabel(u'x轴')plt.ylabel(u'y轴')plt.grid(True)plt.show() 结果图： 也可以动态的决定每个显示时的字体：例子：1234567891011import matplotlib.pyplot as pltfont = matplotlib.font_manager.FontProperties(fname='C:\Windows\Fonts\simsun.ttc')font1 = matplotlib.font_manager.FontProperties(fname='C:\Windows\Fonts\mingliu.ttc')x = [1,2,3,4,5,6,7,8]y = [1,2,3,4,5,6,7,8]plt.plot(x, y)plt.title(u'测试程序',fontproperties=font1)plt.xlabel(u'x轴', fontproperties=font)plt.ylabel(u'y轴', fontproperties=font)plt.grid(True)plt.show() 结果图： 这个图里的’测试程序’和’x轴’是两种字体，也就是说我们可以任意改变每一个label的字体啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线性预测linear prediction]]></title>
      <url>%2F2015%2F12%2F06%2Flinear_prediction%2F</url>
      <content type="text"><![CDATA[线性预测是一种利用之前样品的线性函数来估计未来离散时间信号的值的数学运算方式。 在数字信号处理中,线性预测通常被称为线性预测编码(LPC),因此可以视为滤波器理论的一个子集。在系统分析(数学的一个分支)中,线性预测可以看作是数学建模或者是优化问题的一部分。 1. 预测模型最普通的线性预测表达式是这里的$\widehat{x}(n)$是预测的信号值，$x(n-i)$是之前获得的值，${a}{i}$是预测系数，估计所产生的误差是这里的$x(n)$是正确的信号值。这些方程对于所有类型的一维线性预测都是有效的。对于不同的方法其所不同的是参数 ${a}{i}$ 的选择。对于多维信号而言，误差指标一般被定义为 这里的$\left | . \right |$是一个合适的向量范数。预测函数（$\widehat{x}(n)$）通常使用卡尔曼滤波器和平滑来分别估计当前和过去的信号。 2. 估计参数对于优化参数 $\widehat{x}(n)$，最常见的选择是均方根标准，也被称为自相关性准则。在这个方法中,我们使平方误差的期望值最小化,得到的公式是 1 ≤ j ≤ p这里的R是信号x(n)的自相关性。定义是：这里的 $E$ 是期望值。在多维情况中，这个对应于L2范数的最小化。上面的方程称为normal方程或者Yule-Walker方程。该方程在矩阵形式中可以等价于$Ra=-r$这里的自相关矩阵R是对称的，$p*p$的Toeplitz矩阵，其元素，向量$a$是一个参数向量。另一个更一般的做法是尽可能降低在公式中定义的误差平方和其中对于所有$a_i$的最优化问题，都必须限制在$a_0=-1$内。另一方面，如果均方预测误差被约束为一致的，同时预测误差方程被包括在normal方程的顶部，增广组方程是由得到，其中索引i从0到$p$，同时 $R$ 是一个 $(p + 1) × (p + 1)$ 矩阵。 线性预测参数的规范是一个很广泛的主题,而且大量的方法已经被提出。实际上，自相关方法是最常见的，例如在语音编码GSM标准中使用。 矩阵方程 $Ra = r$在计算量上是一个相对大的过程。矩阵求逆的高斯算法可能是最古老的方法，但这种方法并不能有效地使用R和r的对称性。一个更快的算法是Norman Levinson在1947年提出的Levinson recursion算法，利用递归来解决这个问题。特别是上面的自相关方程，可以更有效地被Durbin算法求解。之后，Delsarte等0提出了一种对于这个算法的改进，称为split Levinson recursion 这个算法需要大约一半乘法和除法。它使用参数向量的一个特殊的对称属性在后来的递归上。也就是说，对于包含$P$项的最优预测点的计算利用了包含$P-1$项的最优预测点的相似计算值。识别模型参数的另一种方式是迭代地计算出使用了卡尔曼滤波器和获得的期望最大化算法中的最大似然估计值的状态估计值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[制作一个python egg 并发布到PyPI]]></title>
      <url>%2F2015%2F11%2F02%2FMake_python_egg%2F</url>
      <content type="text"><![CDATA[最近写了一个可以在终端上输出ASCII表的Python公共库PrintTable，GitHub地址github PrintTable。 最后将脚本打包并且发布到PyPI的过程也是挺长的，第一次学习记录一下。 1. Python脚本 -&gt; 包首先我们先构建出自己包的架构。这里拿PrintTable这个项目的文件结构举例。 Python Packaging User Guide这是Python打包的官方英文文档。 PyPA sample project这是一个官方示例库结构。 ├── LICENSE ├── MANIFEST.in ├── printtable │ ├── __init__.py │ ├── printtable.py ├── README.md ├── setup.cfg ├── setup.py LICENSE：版权信息文件MANIFEST.in：打包时不会被自动包含进去的附加文件清单printtable：Python程序,我们要注意这个文件夹里必须有__init__.py这个文件。即使里面是空的。这样做是为了防止某些目录有一个共同的名字。README.md：项目说明文件setup.py：安装程序文件setup.cfg：包含setup.py额外配置信息的文件 其中setup.py是我们主要需要配置的文件。 from setuptools import setup, find_packages setup( name = 'printtable', version = '1.0', keywords = ('print table'), description = 'a library for drawing the table in the terminal', license = 'MIT License', url = 'https://github.com/prozhuchen/PrintTable', author = 'prozhuchen', author_email = 'prozhuchen@gmail.com', packages = find_packages(), include_package_data = True, platforms = 'any', install_requires = [], ) 上面这些配置信息一般已经够我们用了，如果需要更多的话，setup.py配置信息这是官方文档中setup.py的详细配置信息介绍。 MANIFEST.in文件包含了一些打包时不会被自动包含进去的附加文件。其中最广泛包含进去的是README.md，因为这个项目说明文件打包时不会被自动包含进去。 include README.md 2. 打包通过执行下列语句来进行打包： python setup.py xxx 其中xxx可以是下列几种方式中其中一个： sdist create a source distribution (tarball, zip file, etc.) bdist create a built (binary) distribution bdist_dumb create a "dumb" built distribution bdist_rpm create an RPM distribution bdist_wininst create an executable installer for MS Windows bdist_egg create an "egg" distribution 举个例子： python setup.py sdist #生成的文件支持 pip 此时在根目录出现了dist文件夹，里面有name-version.tar.gz这个文件，这就是我们要发布到PyPI的压缩包了。 3. 发布到PyPI首先我们需要在PyPI上注册一个帐号，你可以选择PyPI注册页面和命令行注册两种方式： $ python setup.py register -r pypi running register running egg_info writing printtable.egg-info/PKG-INFO writing top-level names to printtable.egg-info/top_level.txt writing dependency_links to printtable.egg-info/dependency_links.txt reading manifest file 'printtable.egg-info/SOURCES.txt' reading manifest template 'MANIFEST.in' writing manifest file 'printtable.egg-info/SOURCES.txt' running check We need to know who you are, so please choose either: 1. use your existing login, 2. register as a new user, 3. have the server generate a new password for you (and email it to you), or 4. quit Your selection [default 1]: 1 Username: prozhuchen Password: Registering prinble to https://pypi.python.org/pypi Server response (200): OK I can store your PyPI login so future submissions will be faster. (the login will be stored in /home/zc/.pypirc) Save your login (y/N)?y 当你注册完毕后，会在用户根目录下创建文件~/.pypirc，这样以后就不需要输入帐号密码了。 然后我们需要向PyPI上发布自己的源代码包。 $python setup.py sdist upload ... Creating tar archive removing 'printtable-1.0' (and everything under it) running upload Submitting dist/printtable-1.0.tar.gz to https://pypi.python.org/pypi Server response (200): OK 此时在网页上就可以看到自己的源代码包啦。现在我们使用pip install packagename,就可以使用我们自己写的Python库了。 每次我们想更新我们自己的库时，只需要更新代码文件夹内的代码和setup.py里的version即可。 4. 注意每次上传时，我们的名字或者版本号两者有一个必须和以前的不一样，也就是打包生成的name-version.tar.gz名字和以前上传的压缩包不一样才行。覆盖是行不通的哦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shell错误 let:not found]]></title>
      <url>%2F2015%2F10%2F19%2Fshell_error%2F</url>
      <content type="text"><![CDATA[今天遇到个错误: zc@zc-HP-242-G1-Notebook-PC:~$ ./1.sh 1.sh: 7: 1.sh: let: not found 查了一下，发现是因为/bin/sh默认的软连接是dash，不是bash,我们可以通过下面的命令在/bin目录下看见这个: zc@zc-HP-242-G1-Notebook-PC:/bin$ ll sh lrwxrwxrwx 1 root root 4 Aug 23 2014 sh -&gt; dash* 我们直接bash 1.sh就可以了。当然想永远解决的我们有两种方法解决： 我们可以通过chsh命令进行改变，chsh可以改变目前用户的shell类型。 zc@zc-HP-242-G1-Notebook-PC:/bin$ chsh 密码： 正在更改 zc 的 shell 请输入新值，或直接敲回车键以使用默认值 登录 Shell [/bin/bash]: 我这里直接是我想要的，所以敲回车即可。如果不是/bin/bash，你就写这个路径就行啦。但是这个命令有一个缺点： zc@zc-HP-242-G1-Notebook-PC:~$ ./1.sh count = 2 zc@zc-HP-242-G1-Notebook-PC:~$ sh 1.sh 1.sh: 7: 1.sh: let: not found count = 1 大家不用关心这个输出是什么…但是我们看到了用.是成功了,用sh还是let: not found。 第二个方法是改变/bin/sh的连接。输入命令sudo ln -sf /bin/bash /bin/sh，然后输入ll /bin/sh，可以看到下面的情况。 zc@zc-HP-242-G1-Notebook-PC:~$ sudo ln -sf /bin/bash /bin/sh zc@zc-HP-242-G1-Notebook-PC:~$ ll /bin/sh lrwxrwxrwx 1 root root 9 Oct 19 12:05 /bin/sh -&gt; /bin/bash* 这次就算是解决了。 zc@zc-HP-242-G1-Notebook-PC:~$ sh 1.sh count = 2 zc@zc-HP-242-G1-Notebook-PC:~$ ./1.sh count = 2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客之改字体]]></title>
      <url>%2F2015%2F10%2F05%2FHexo_blog_7%2F</url>
      <content type="text"><![CDATA[觉得自己的博客字体不好看，在网上找了半天也没有相应的资料，所以这一次我们来看看杂么改掉自己Hexo博客的字体。 首先找到自己字体和字体大小的文件。字体在/themes/hexo-theme-next/source/css/_variables下的custom.styl（这个是NexT主题的目录，其他主题请按图索骥）。字体大小在/themes/hexo-theme-next/source/css/_variables下的base.styl。 然后我们来看怎么改动。custom.styl文件： $font-family-headings = Georgia, sans // 标题，修改成你期望的字体族 $font-family-base = "Microsoft YaHei", Verdana, sans-serif // 修改成你期望的字体族 我们可以看出来第一个字体变量是题目的字体，第二个是其余部分的字体。因为我们是中文博客，所以肯定希望能改成一些比较漂亮的中文字体，但是显而易见，你改成宋体是不合理的，因为第一会出现乱码情况，第二Hexo也不接受中文名字的字体。所以我们需要使用中文字体的英文名称。下面是中文字体对应的英文名称。 新细明体：PMingLiU 细明体：MingLiU 标楷体：DFKai-SB 黑体：SimHei 宋体：SimSun 新宋体：NSimSun 仿宋：FangSong 楷体：KaiTi 仿宋_GB2312：FangSong_GB2312 楷体_GB2312：KaiTi_GB2312 微软正黑体：Microsoft JhengHei 微软雅黑体：Microsoft YaHei 装Office会多出来的一些字体： 隶书：LiSu 幼圆：YouYuan 华文细黑：STXihei 华文楷体：STKaiti 华文宋体：STSong 华文中宋：STZhongsong 华文仿宋：STFangsong 方正舒体：FZShuTi 方正姚体：FZYaoti 华文彩云：STCaiyun 华文琥珀：STHupo 华文隶书：STLiti 华文行楷：STXingkai 华文新魏：STXinwei 苹果电脑中的字体： 华文细黑：STHeiti Light [STXihei] 华文黑体：STHeiti 华文楷体：STKaiti 华文宋体：STSong 华文仿宋：STFangsong 丽黑 Pro：LiHei Pro Medium 丽宋 Pro：LiSong Pro Light 标楷体：BiauKai 苹果丽中黑：Apple LiGothic Medium 苹果丽细宋：Apple LiSung Light 我们只要将自己喜欢字体的英文名加到这两个变量的第一个前面就可以了，有多个字体是为了预防在某些场合前面的字体出现异常，后面的字体可以替代一下。下面是我的定义。 $font-family-headings = KaiTi,"Microsoft YaHei",Georgia, sans // 标题，修改成你期望的字体族 $font-family-base = SimHei, Verdana, sans-serif // 修改成你期望的字体族 至于字体大小，我们在前面提到的base.styl里面61行左右会看见如下定义： // Font size $font-size-base = 18px $font-size-small = $font-size-base - 2px $font-size-smaller = $font-size-base - 4px $font-size-large = $font-size-base + 4px // Headings font size $font-size-headings-base = 28px $font-size-headings-step = 2px 同理，第一个部分$font-size-base是除了标题外的其余部分大小，第二个部分$font-size-headings-base是标题大小，你改动成你希望的大小就可以了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客第九又四分之三站：剩下的小东西]]></title>
      <url>%2F2015%2F10%2F04%2FHexo_blog_6%2F</url>
      <content type="text"><![CDATA[最后看了看还是有点小东西没说，但是前面都已经写完结尾了啊啊啊，所以在此补了个九又四分之三站(不知道深意的请百度哈利波特站台….)，有缘分的小伙伴进来看一看有木有你能用上的。 1. Hexo + README每次进入GitHub的gh-pages分支都提醒写README，烦死了，我们在根目录下的source下面新建一个README文件，写上对自己博客的描述啥的，再次生成部署就会发现README已经传上去了。 2. Hexo + 404GitHub本身给我们配置了404页面，如果是做自己的404页面，你可以像上面一样，在source里面加上404.html，但是注意，自定义的404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。例如，如果一开始你的域名是XXX.github.io,你就可以在XXX.github.io/404.html看到你的404页面，但是如果你的域名是XXX.github.io/blog，那么你就无法看到自己的404了。现如今，很多人都把自己的404页面当做公益项目的传播，为社会做点自己的贡献，例如这样子：404页面。下面是几个公益404的地址。 腾讯公益404 404公益_益云(公益互联网)社会创新中心 失蹤兒童少年資料管理中心404 3. hexo + 图床我们的博客部署在GitHub上虽然有很多好处，但是有一个问题，他的个人空间只有100M！如果光是普通文件也就差不多够了，但是有图片可怎么办呐。所以我们可以把图片放在图床上，然后用外链地址来引用图片，问题解决。我用的图床是七牛，他的体验用户是1G，标准用户是10G，而且免费的，应该够绝大多数个人博客的使用了。这里是七牛的地址 七牛。这里说一下七牛的简单使用。我们首先注册（想成为标准用户得通过个人验证），完成后新建一个空间，名字任意。此时我们进入空间，选择内容管理，然后上传图片，点击该图片后右边会出现图片的缩略图和外链地址，我们复制该外链地址，即图片的访问地址到自己的文章里，就可以看到图片啦。 4. hexo + 社交连接，友情链接我们在站点配置文件中，加入如下的语句，随便加，别客气！ # 社交链接，将在侧栏中显示 social: 知乎: http://www.zhihu.com/people/zhu-chen-71-40 GitHub: https://github.com/prozhuchen # Twitter: your-twitter-url # Weibo: your-weibo-url # DouBan: your-douban-url # ZhiHu: your-zhihu-url # 等等 #友情链接，将在侧栏中显示 links_title: 友情链接 links: 我的CSDN博客: http://blog.csdn.net/u010006643 5. 结束啦首先感谢网上大神们的博客，很牛，也解决了自己的很多问题，可惜好多博文没有记住…..如果您发现了我引用了你的博客，而且需要我进行说明，我将会尽快说明，在此感谢大神们博客的帮助。经过这几天的整理，总算把自己挖空了。请小伙伴们如果发现错误在下面留言告诉我，我将不胜感激。有疑问的话我也会尽力给大家解决。希望大家能愉快的交流与学习&lt;(￣ˇ￣)/。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客第五站：文章配置+Markdown语法]]></title>
      <url>%2F2015%2F10%2F03%2FHexo_blog_5%2F</url>
      <content type="text"><![CDATA[现在我们可以尽情写自己想写的东西了。但是首先我们得学会在哪写和怎么写。 1. 在哪写(Hexo 文章配置)1.1 从别处迁移如果我们之前在别的网站已经有了自己,./的博客，那当然不能直接扔掉啦，Hexo可以从RSS/Jekyll/Octopress/Wordpress迁移之前的博客（传送门 从别处迁移到Hexo）。 1.2 自己写首先我们在Git Bash中输入： hexo new "article name" 然后我们在博客根目录/source/_posts下会看见新产生的article name.md。如果我们想改变这个名字的格式，就可以在站点配置文件的31行左右改变new_post_name，下面将名字格式改成了类似这样的2015-09-29-name.md： # Writing new_post_name: :year-:month-:day-:title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false 然后重新生成一篇文章，可以看到产生的是2015-09-29-article name.md吧。 此时我们进入这篇文章，可以看见： title: q //文章的名字 date: 2015-10-03 15:53:11 //你生成这篇文章的时间 tags: //文章的标签 .... 类似这样的开头属性还有： updated 修改日期 文件的修改日期 comments 是否开启评论 true(默认) tags 文章标签 categories 文章分类 permalink url中的名字 文件名 description 文章摘要 举两个例子： //这个文章不允许别人评论，默认评论是开启的 title: Hexo博客第二站：部署到GitHub date: 2015-09-28 20:29:48 comments: false //这个文章有两个标签，属于两个类别 title: Hexo博客第二站：部署到GitHub date: 2015-09-30 15:06:50 tags: - Hexo - GitHub categories: - Hexo - GitHub 接下来我们就可以在下面写自己的文章啦，但是文章要符合Markdown语法，MarkDown语法是啥子？我们要咋写啊？ 2. 怎么写（Markdown） Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。 网上有很多的Markdown软件，我用的是作业部落，感觉这个软件做的很不错。其他的也有一些人是用sublime+插件（传送门 sublime text 2 下的Markdown写作），大家可以自己选择自己想要的。 至于Markdown语法，一开始准备自己写，但是后来发现有好多内容网上已经有了，再写出来会很重复。所以基本语法我就不提了。在这里说一些我在用Markdown时的心得。 NexT主题有一个配置选项toc_list_number: true，这个选项使我们的目录会自动配上顺序标号，所以我们在自己写的时候可以不用带上了，如果不习惯的话，把这个配置注释掉即可。 在用Markdown写命令的时候，我们将命令缩进四个空格，就会出现下面的情况。 此处是你的命令 绝大部分时候，一个Tab就是四个空格，当然你也可以设置，例如用sublime写作时，你就可以设定一个Tab等于多少空格。 在用Markdown写代码的时候，我们只要用三个点将代码包起来就可以，Markdown会自动进行代码高亮和分辨语言。就像这样： 1#include&lt;stdio.h&gt; Markdown变得越来越流行，他的兼容性和可读性可以胜任各个场合，而且如果伴随着一些专业编辑器，我们的写作速度大大加快了。 从现在开始，大家可以开始自己的博客创作之路了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客第四站：搜索引擎+小插件+配置结构分析]]></title>
      <url>%2F2015%2F10%2F03%2FHexo_blog_4%2F</url>
      <content type="text"><![CDATA[接着我们上次来继续加加加东西。 此时说明一下，大家可能看到我的博客和你们NexT主题显示的不一样，这是因为NexT主题包含两种主题，我们在主题配置文件中的40行左右可以看见： # Schemes scheme: Mist #这一列默认是注释掉的，如果把这个取消注释，就会变成我的博客的主题样式。 1. 搜索引擎NexT主题支持了两种搜索引擎：Swiftype和微搜索。一个是国外的，一个是国内的。微搜索做的还不错，但是我搜索的时候总觉得有些延迟；至于Swiftype，真的真的很好用，良心厂家强力推荐。有人说注册以后是30天试用，这个没关系，网站给的是30天高级账户的使用（那种有可以建立多个搜索引擎、多账户共同管理、一个引擎index多个域名的功能的账户），30天到期后你可选择花钱继续用这个高级账户（土豪自便），或者选择降级成为免费的账户类型，也就是我现在用的那种，所以，不用担心。Swiftype网站的配置，网上其他好多的都是说的老版Swiftype的配置，比较落后了，这里提供给大家一位博主的博客，说的很详细。传送门 利用swiftype为hexo添加站内搜索。至于主题上的配置，我们只要在你的站点配置文件（不是主题配置文件）上加上这样一句话即可。 # Swiftype Search Key swiftype_key: 你的swiftype_key swiftype_key：在你Swiftype网站配置完后，我们看到了一个JS文件。 12345678&lt;script type="text/javascript"&gt; (function(w,d,t,u,n,s,e)&#123;w['SwiftypeObject']=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st'); _st('install','yx9-swpbwqxuFPaTyCzz','2.0.0');//yx9-swpbwqxuFPaTyCzz 就是 swiftype_key，不同的人不一样。&lt;/script&gt; 2. 安装插件RSS与 sitemapSitemap: Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。 这个Sitemap还是很有用的，例如本来你在google上搜索自己的新帖子是很难搜索到的，但是你向google提交sitemap后，自己的帖子变得容易搜索到多了。 RSS: RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网站内容的格式。你可以认为是一种定制个性化推送信息的服务。它能解决你漫无目的浏览网页的问题。它不会过时，信息越是过剩，它的意义也越加彰显。 首先我们安装前人写好的插件。 npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 然后在站点配置文件上输入下面的语句： plugins: - hexo-generator-feed - hexo-generator-sitemap sitemap: path: sitemap.xml feed: path: atom.xml 上面的path说明了博客生成后的位置在根目录下，也是你访问网址是你的根地址+path。此时你访问http://127.0.0.1:4000/atom.xml就能看到RSS的内容啦，sitemap访问同理。 如果想向google提交自己的sitemap，请看这个博客。传送门 如何向google提交sitemap（详细） ，过一天左右，你就能在google搜索到自己的新博客啦。 3. 加入”关于我” 和DIY界面一开始我们的主页里面只有主页，归档和标签三个栏目。我们可以加一些自己DIY的界面。我们在Git Bash中输入这样一句命令。 hexo new page "about" 这时我们进入博客根目录下的source可以发现多了一个about文件夹，里面有一个index.md,此时我们进入主题配置文件（就是在主题目录下的_config.yml），对第五行进行更改。 menu: home: / #categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 此时再重新生成可以看见我们的页面多了一个关于的栏目啦。如果我们想加入一些新的栏目，例如我上面出现的留言呢，可以再次这么敲命令： hexo new page "guestbook" 然后在主题配置文件进行更改，加一句 guestbook: guestbook。 menu: home: / #categories: /categories about: /about archives: /archives tags: /tags guestbook: guestbook #commonweal: /404.html 此时我们重新生成发现页面上多出来的是guestbook，而不是我们想要的留言。这时候我们在/themes/hexo-theme-next/languages/zh-Hans.yml的目录下（这里默认你使用的是简体中文，若是其他语言更改相应的yml就行），在memu下加一句即可。 guestbook: 留言 此时再重新生成可以看见我们的页面多了一个留言的栏目啦。如果你想要其他的DIY栏目，勇敢的去做吧！ 4. 主题配置文件结构分析主题配置文件就是在主题目录下的_config.yml，这里对我们常用的配置进行一下讲解。 # when running hexo in a subdirectory (e.g. domain.tld/blog), remove leading slashes ( "/archives" -&gt; "archives" ) menu: # 这是你主页最上面出现的栏目 home: /blog/ archives: /blog/archives categories: /blog/categories tags: /blog/tags guestbook: /blog/guestbook # about: /blog/about # commonweal: /blog/404.html # Place your favicon.ico to /source directory. favicon: images/favicon.ico #这是我们网站的图标 # Set default keywords (Use a comma to separate) keywords: "Hexo,next" # Set rss to false to disable feed link. # Leave rss as empty to use site's feed link. # Set rss to specific value if you have burned your feed already. rss: /blog/atom.xml #这是我们RSS的地址 # Icon fonts # Place your font into next/source/fonts, specify directory-name and font-name here # Avialable: default | linecons | fifty-shades | feather #icon_font: default #这是我们图标字体的样式 # icon_font: fifty-shades icon_font: feather #icon_font: linecons # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: night eighties #这是我们代码高亮的样式，你可以自己改变来看看每一种样式。 # MathJax Support mathjax: true #显示数学公式的功能，默认是空，如果打开就设为true # Schemes scheme: Mist #NexT主题有两种主题，这里默认是注释掉的，取消注释的话就是我博客的样式。 # Sidebar, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. sidebar: post #这个是侧边栏的显示模式，默认是在阅读帖子的时候自动打开。 #sidebar: always #sidebar: hide # Automatically scroll page to section which is under &lt;!-- more --&gt; mark. scroll_to_more: true #启动摘取一部分作为摘要，剩余的在阅读全文里。 # Automatically add list number to toc. toc_list_number: true #自动在目录里加入列表数字 到现在基本的东西我们都算是有啦，现在可以准备开始写博客了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客第三站：安装主题+第三方评论+网站统计]]></title>
      <url>%2F2015%2F10%2F01%2FHexo_blog_3%2F</url>
      <content type="text"><![CDATA[接着我们开始丰富我们的博客。 再次提示： 下面输入的命令都在 Git Bash 中输入。 下文提到的目录地址都是面对NexT主题的，不过其他主题的索引也都大同小异。 1. hexo博客结构在这里，我们先来看看hexo自动生成的博客的主要结构。 ├─scaffolds //每篇帖子模板所在地 ├─source │ └─_posts //这里放着我们写的帖子 里面初始化一篇hello-world.md └─themes //hexo博客主题所在地 └─landscape //初始化主题默认为landscape ├─node_modules //hexo的驱动文件所在地 ├─_config.yml //hexo博客配置文件 这些都是我们有可能去改变的。看完了这个，接下来开始让我们的博客变得添砖加瓦吧。 2. 添砖加瓦2.1 安装主题一个好看的主题可以更加吸引读者，但是从头设计主题也太麻烦了吧~，所以Hexo有很多现成的主题。传送门 [ Hexo主题 ]我们利用语句下载下来我们需要的主题。例如我们下载hexo-theme-next这个主题。 $ git clone https://github.com/iissnan/hexo-theme-next.git themes/hexo-theme-next 然后进入上面提到的 themes 文件夹下，可以看见出现了hexo-theme-next文件夹。此时我们到博客根目录下的 _config.yml，修改博客所用的主题 (第66行) 。 # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: hexo-theme-next 改完后，我们在 Git Bash 中输入 hexo g hexo s 进入 [ http://127.0.0.1:4000/ ] 查看我们的页面，是不是变得高大上多啦。这一章主要是完善博客所必须的一些内容。 2.2 第三方评论博客怎么能没有让小伙伴说话的地方呢。因为Hexo博客是静态博客，所以评论系统我们得靠其他的插件了。NexT这个主题支持 Disqus 和多说两种第三方评论插件。我使用的是多说。Disqus的看这里有提到 Hexo在github上构建免费的Web应用。 进入多说平台，点击 “ 我要安装 “ 。 配置好自己的站点，注意多说域名这一栏是我们接下来需要的东西。站点地址就是你Hexo博客上传的GitHub页面地址。 在你的站点配置文件 (不是主题配置文件) _config.yml加一行：duoshuo_shortname: 你的多说域名 ( 多说域名: 你的多说二级域名去掉 .duoshuo.com 部分 ) 再次生成上传 hexo g，hexo d （没有事先部署到GitHub上的看这里 Hexo博客第二站：部署到GitHub上）,点击文章hello-world，是不是看见最下方出现了评论系统啦。管理的话进入多说的后台管理就行了。 **有人可能觉得多说的标准css样式不怎么好看。你可以进入后台管理-设置-基本设置-自定义CSS里面编辑自己想要的。我用的是从网上借鉴来，自己改动了一些的。12345678910111213141516171819202122232425262728293031323334353637383940414243#ds-reset .ds-avatar,#ds-recent-visitors .ds-avatar&#123; filter: alpha(opacity=0); /*设置图片背景透明*/ background-color: rgb(0, 0, 0); background-color: rgba(0, 0, 0, 0); &#125;#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; /*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff; rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff; rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*隐藏多说底部版权*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 2.3 博客分享我们的博客写的好，会有人希望分享给其他人看。NexT主题有两个分享部件：多说分享和JiaThis。多说分享首先必须启用了多说才能使用。我们在站点配置文件下加上如下的语句，如果你想开启多说分享服务，把jiathis注释掉，取消duoshuo_share的注释就行啦。 # JiaThis 分享服务 jiathis: true # 多说热评文章服务 duoshuo_hotartical: true # # 多说 分享服务（必须启用多说） # duoshuo_share: true 2.4 网站统计其实我觉得google，百度统计这些对于许多人用不太上，毕竟不能直接观察到自己的博客有多少人看了什么的。如果需要安装的看这里&gt;添加 Google, 百度统计。这里推荐一个小插件-不蒜子。这个小插件可以让你轻而易举的看见自己的博客火热程度，例如访问量和访问人数等。 有一个好玩的小地方，你为了想看到每一篇文章的阅读量，你可以在/themes/hexo-theme-next/layout/_macro/post.swig里面的下面的位置加上如下代码，(这个热度是从一个博客上看到的，感觉很有趣哈):12345678910111213141516171819202122&#123;% if post.categories and post.categories.length %&#125; &lt;span class="post-category" &gt; &lt;/span&gt; &#123;% endif %&#125; &lt;!-- 在下面的位置加上如下代码 --&gt; &lt;span id="busuanzi_container_page_pv"&gt; &amp;nbsp; | &amp;nbsp; 热度&amp;nbsp; &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;°C &lt;/span&gt; &lt;!-- 在上面的位置加上如上代码 --&gt; &#123;% if post.comments %&#125; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;span class="post-comments-count"&gt; &amp;nbsp; | &amp;nbsp; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;#comments" itemprop="discussionUrl"&gt; &lt;span class="post-comments-count ds-thread-count" data-thread-key="&#123;&#123; post.path &#125;&#125;" itemprop="commentsCount"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; 但是这有一个缺陷。就是我们会发现在主页时显示的热度和进入博客后的热度不一样，那是因为在主页时他显示的是主页这个页面的阅读量，而不是博客的阅读量，所以我们需要改变一些 (不会该代码的哭死╥﹏╥… )：我们在/themes/hexo-theme-next/layout/_macro/目录下新建post-article.swig,把这些post.swig中的内容复制过去，而且加上上面的统计代码，然后在/themes/hexo-theme-next/layout/post.swig上面% import &#39;_macro/post.swig&#39; as post_template %中的post.swig改成post-article.swig，这样子就解决啦。就是在主页上的博客名字下面不会有阅读人数，进入博客才能看见。为了给大家尽量详细的说明，不知不觉发现这篇文章写得好长^O^ ，下次接着写。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客第二站：部署到GitHub]]></title>
      <url>%2F2015%2F09%2F30%2FHexo_blog_2%2F</url>
      <content type="text"><![CDATA[我们开始把Hexo博客部署在GitHub上。 首先声明一点，作为一个静态博客，Hexo不止能部署在Git上，只要支持Web访问的空间都可以存放Hexo静态博客。不过GitHub作为一个程序员聚居地，年轻的我们也需要靠近组织嘛。在这里我们假设小伙伴都已经有了一个GitHub账号，并且有了一个GitHub博客。如果没有做的请看这里 &gt; GitHub博客搭建。 注意：下面的命令在Git Bash上运行。 1. GitHub生成 SSH key1.1 生成 SSH key作为第一步，首先得让我们的电脑连上GitHub。输入ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;,接下来就是不断的敲回车就可以啦。 ssh-keygen -t rsa -b 4096 -C "your_email@example.com" # Creates a new ssh key, using the provided email as a label Generating public/private rsa key pair. Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] Your identification has been saved in /Users/you/.ssh/id_rsa. Your public key has been saved in /Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 此时在你电脑的 C:\Users\用户名\.ssh\这个目录下就可以找到我们需要的SSH key - id_rsa.pub了。此时在你的GitHub的settings里找到SSH keys，把id_rsa.pub里面的东西添加到Add an SSH key的key里面。然后在Git Bash里面输入ssh -T git@github.com: $ ssh -T git@github.com Hi prozhuchen! You've successfully authenticated, but GitHub does not provide shell access. 第一步成功！ 1.2 输入ssh -T git@github.com 时出现的错误 输入ssh -T git@github.com出现Permission denied (publickey)借鉴这篇博文 git连接github失败的问题。 出现ssh:connect tohost github.com port22:Bad file number可以看出是端口出现了问题，22是默认的ssh端口，但一般好像是关上的，所以我们改掉端口。我们在SSH key的目录下(一般是C:\Users\用户名\.ssh\)新建一个config文件，内容是： Host github.com User fulinux@sina.com Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 在此尝试连接，应该可以了。 2. Hexo部署到GitHub上2.1 Hexo部署我们首先进入到Hexo的站点配置文件_config.yml，修改Deployment部分。 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:prozhuchen/blog.git branch: gh-pages 这里的repo是你的GitHub博客的SSH地址,branch是你想部署在该仓库的分支。如果不知道自己博客的SSH地址的小伙伴看这里：当然了，你首先得点击clone with HTTPS,SSH;里面的SSH，然后框框里的就是你博客的SSH地址了。然后输入： hexo g hexo d 可以看见： $ hexo d INFO Deploying: git INFO Clearing .deploy folder... INFO Copying files from public folder... ..... Branch master set up to track remote branch gh-pages from git@github.com:prozhuchen/blog.git. Everything up-to-date INFO Deploy done: git 此时去看你自己的GitHub博客吧~(地址应该是username.github.io或者是.com)。接下来我们来看看如果让我们的博客变得更完美了。 2.2 输入hexo d时出现的问题 ERROR Deployer not found: git 确定自己安装了hexo-deployer-git。如果没有,在Git Bash上输入：npm install hexo-deployer-git --save。 deploy的type的github需要改成git。 注意_config的配置写法。注意缩进，而且冒号后面要有一个空格。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客第一站：搭建本地Hexo静态博客]]></title>
      <url>%2F2015%2F09%2F30%2FHexo_blog_1%2F</url>
      <content type="text"><![CDATA[首先我们先在本地搭一个静态的hexo博客。 1. Hexo的优势Hexo是一款基于Node.js的静态博客，他的优势在于可以快速的搭建起一个个人博客，并且支持各种评论，分享等插件，最重要的是，它有很多现成的主题，你可以任意选择。 2. Hexo安装首先说明一点，此处的安装是在windows上的。linux的看这里: Ubuntu下用Hexo搭建个人博客 安装Git. Git安装地址 安装Node.js. Node.js安装地址此时你点击任意文件夹右键，应该有 Git Bash here。进入后输入 node -v和 npm -v，如果显示版本号则安装成功。 安装Hexo.在Git bash中输入 npm install -g hexo。 Hexo初始化。 你可以cd到你选择的目录，然后输入 hexo init npm install 或者直接输入 hexo init 你选择的目录 npm install 此时在你选择的目录下,输入 hexo g 和 hexo s。 hexo g //生成静态网页 INFO Files loaded in 705 ms INFO Generated: js/script.js ... INFO Generated: archives/2015/09/index.html INFO Generated: index.html INFO 28 files generated in 1.95 s hexo s //启动服务器 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时你打开 http://127.0.0.1:4000 , 就能看到已经生成的Hexo界面啦。 3. Hexo常用命令这里先说一下Hexo常用的命令，接下来的文章也会提醒一些的。 $ hexo new [layout] &lt;title&gt; #建立新文章，默认在_posts下，layout="draft"时发布的是草稿 $ hexo publish &lt;filename&gt; #将_drafts下的文件放到_posts下，也就是发布草稿 $ hexo generate #生成静态网页 $ hexo server #启动预览服务器，开启-d选项时可以预览草稿 $ hexo deploy #发布到远程服务器，开启--generate选项可以在deploy前自动generate 另外这些命令都有简化命令，接下来我使用简化命令多一些。 $ hexo n # == hexo new $ hexo p # == hexo publish $ hexo g # == hexo generate $ hexo s # == hexo server $ hexo d # == hexo deploy 4. 注意有的时候输入 hexo init看到了这句话： -bash: hexo: command not found 说明没找到hexo指令，此时我们找到hexo的下载目录，然后在系统变量path添加就可以了。我的目录是在 C:\Users\用户名\AppData\Roaming\npm\node_modules\hexo\bin。大家的应该也在类似位置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[各种排序代码集合笔记]]></title>
      <url>%2F2015%2F09%2F03%2Fvary_sort_code%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;stdio.h&gt;//直接插入排序void InsertSort(int *datatemp,int n)&#123; int *data = new int[n]; for(int i=0;i&lt;n;i++)&#123; data[i]=datatemp[i]; &#125; int temp,j; for(int i=2;i&lt;n;i++)&#123; temp = data[i]; if(data[i]&lt;data[i-1])&#123; j = i-1; while(data[j]&gt;temp)&#123; data[j+1]=data[j]; j--; &#125; data[j+1]=temp; &#125; &#125; //输出 printf("直接插入排序:\t"); for(int i=1;i&lt;n;i++)&#123; printf("%d ",data[i]); &#125; printf("\n");&#125;//希尔排序void ShellSort(int *datatemp,int n)&#123; int *data = new int[n]; for(int i=0;i&lt;n;i++)&#123; data[i]=datatemp[i]; &#125; int dk = n/2; while(dk&gt;=1)&#123; //插入排序了下面是 for(int i=dk;i&lt;n;i+=dk)&#123; int temp = data[i]; if(data[i]&lt;data[i-dk])&#123; int j = i-dk; while(data[j]&gt;temp)&#123; data[j+dk]=data[j]; j-=dk; &#125; data[j+dk]=temp; &#125; &#125; dk/=2; &#125; //输出 printf("希尔排序:\t"); for(int i=1;i&lt;n;i++)&#123; printf("%d ",data[i]); &#125; printf("\n");&#125;//快速排序int QsortThird(int low,int high ,int *data)&#123; int temp = data[low]; while(low&lt;high)&#123; while(low&lt;high &amp;&amp; data[high]&gt;=temp)high--; data[low]=data[high]; while(data[low]&lt;=temp &amp;&amp; low&lt;high) low++; data[high]=data[low]; &#125; data[low]=temp; return low;&#125;void QsortSecond(int low,int high ,int *data)&#123; if(low&lt;high)&#123; int mid = QsortThird(low,high,data); QsortSecond(low,mid-1,data); QsortSecond(mid+1,high,data); &#125;&#125;void QsortFrist(int *datatemp,int n)&#123; int *data = new int[n]; for(int i=0;i&lt;n;i++)&#123; data[i]=datatemp[i]; &#125; QsortSecond(1,n-1,data); //输出 printf("快速排序:\t"); for(int i=1;i&lt;n;i++)&#123; printf("%d ",data[i]); &#125; printf("\n");&#125;//归并排序void Merge(int *A,int low,int mid,int high,int *B)&#123; int x=low,m=mid,y=mid+1,n=high; int k=0; while(x&lt;=m &amp;&amp; y&lt;=n)&#123; if (A[x] &lt;= A[y]) B[k++]=A[x++]; else B[k++]=A[y++]; &#125; while(x&lt;=m)&#123; B[k++]=A[x++]; &#125; while(y&lt;=n)&#123; B[k++]=A[y++]; &#125; //把已经有序的序列再返回 for (int i = 0; i &lt; k; i++) A[low+i] = B[i]; &#125;void MergeSortSecond(int *A,int low,int high,int *B)&#123; if(low&lt;high)&#123; int mid = (low+high)/2; MergeSortSecond(A,low,mid,B); MergeSortSecond(A,mid+1,high,B); Merge(A,low, mid, high, B); &#125;&#125;void MergeSortFirst(int *datatemp,int n)&#123; int *data = new int[n]; for(int i=0;i&lt;n;i++)&#123; data[i]=datatemp[i]; &#125; int *datatmp = new int[n]; MergeSortSecond(data,1,n-1,datatmp); //输出 printf("归并排序:\t"); for(int i=1;i&lt;n;i++)&#123; printf("%d ",data[i]); &#125; printf("\n");&#125;//堆排序void HeapSort()&#123;&#125;int main()&#123; int data[8]=&#123;0,49,38,65,97,76,13,27&#125;;//后七个数是数据，第一个是哨兵，这里为了做例子才这么写 //输出 printf("原始数据:\t"); for(int i=1;i&lt;8;i++)&#123; printf("%d ",data[i]); &#125; printf("\n"); InsertSort(data,8); ShellSort(data,8); QsortFrist(data,8); MergeSortFirst(data,8); return 0;&#125; 还没写完，有空把堆排序补上。]]></content>
    </entry>

    
  
  
</search>
