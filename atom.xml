<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[朱琛的小屋]]></title>
  <subtitle><![CDATA[zhuchen01@ict.ac.cn]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://prozhuchen.com/"/>
  <updated>2017-01-22T10:43:10.303Z</updated>
  <id>http://prozhuchen.com/</id>
  
  <author>
    <name><![CDATA[朱琛]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[c++ primer 笔记第十二弹 - 动态内存]]></title>
    <link href="http://prozhuchen.com/2017/01/22/c++primer_note12/"/>
    <id>http://prozhuchen.com/2017/01/22/c++primer_note12/</id>
    <published>2017-01-22T10:28:17.000Z</published>
    <updated>2017-01-22T10:43:10.303Z</updated>
    <content type="html"><![CDATA[<p>c++ primer中第十二章：动态内存的笔记。<a id="more"></a></p>
<h1 id="内存类型分类">内存类型分类</h1><ol>
<li>静态内存：静态内存用来保存局部static对象，类static数据成员，以及定义在任何函数之外的变量。</li>
<li>栈内存：用来保存在函数内的非static对象，由编译器进行自动创建和销毁。</li>
<li>堆内存：又称自由空间。是我们在程序运行时分配的对象。动态对象的生存期由程序来控制。所以需要我们显式的销毁。</li>
</ol>
<h1 id="直接管理内存_-new_，delete">直接管理内存 -<code>new</code> ，<code>delete</code></h1><ol>
<li>如果<code>new</code>无法分配所要求的内存空间，它会抛出一个类型为<code>bad_alloc</code>的异常。</li>
<li><code>new</code>的作用是分配所需内存，返回指向该对象的指针</li>
<li><code>delete</code>的作用是销毁给定指针指向的对象，释放对应内存。</li>
<li><code>new</code>是可以分配<code>const</code>对象的。</li>
<li>动态内存不同于之前的<code>shared_str</code>，他不会自动释放，所以它的生存期一直到被显式释放之前。但是在很多情况下，我们都容易忘记释放内存，导致内存泄露。</li>
</ol>
<p>直接管理内存的劣势：</p>
<ol>
<li><p>忘记<code>delete</code>内存。</p>
</li>
<li><p>使用已经释放过的对象。</p>
</li>
<li><p>同一块内存释放两次。</p>
</li>
<li><p>特别是我们有多个指针指向同一块内存，当其中一个指针<code>delete</code>后，其他指针指向的内存也没有了，此时所有指针无效了。但是我们容易忘记该事实。</p>
</li>
</ol>
<h1 id="智能指针">智能指针</h1><p>智能指针是c++11新标准颁布的，用来管理动态内存。智能指针与以前的<code>new，delete</code>区别主要在于他可以自动释放所指向的对象。主要有两类智能指针：<code>shared_ptr</code>和<code>unique_str</code>。<code>shared_ptr</code>允许多个指针指向同一个对象，<code>unique_str</code>独占所指向的对象。</p>
<h2 id="shared_ptr"><code>shared_ptr</code></h2><p><code>shared_ptr</code>也是一种模板，定义时我们需要提供指针可以指向的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;    <span class="comment">//可以指向string类型</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; p2; <span class="comment">//可以指向list&lt;int&gt;类型</span></span><br></pre></td></tr></table></figure>
<h3 id="shared_ptr分配内存"><code>shared_ptr</code>分配内存</h3><p><code>shared_ptr</code>使用<code>make_shared</code>标准库函数来分配内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr that points to an int with value 42</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 points to a string with value 9999999999</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p4 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, ’<span class="number">9</span>’);</span><br><span class="line"><span class="comment">// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>注意一点，调用<code>make_shared&lt;string&gt;时</code>传递的参数必须与<code>string</code>的某个构造函数相匹配。如果不传递任何参数，对象会自己进行初始化。</p>
<p>我们也可以使用c++11新标准的<code>auto</code>关键字进行定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="shared_ptr拷贝与赋值"><code>shared_ptr</code>拷贝与赋值</h3><p>当进行拷贝与赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他的<code>shared_ptr</code>指向相同的对象。</p>
<p>每一个<code>shared_ptr</code>都有一个关联的计数器。当我们拷贝一个<code>shared_str</code>时，计数器就会递增。</p>
<p>基本上一个例子我们就能明白。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// r指向的int只有一个引用者</span></span><br><span class="line">r = q; 	<span class="comment">// r指向了q所指向的地址</span></span><br><span class="line">		<span class="comment">// 递增q所指向对象的引用计数</span></span><br><span class="line">		<span class="comment">// 递减r原来所指向对象的引用计数</span></span><br><span class="line">		<span class="comment">// r原来所指向对象的引用计数为0，即没有引用者，自动释放</span></span><br></pre></td></tr></table></figure>
<h3 id="shared_str自动销毁所指对象"><code>shared_str</code>自动销毁所指对象</h3><p><code>shared_str</code>是通过一个特殊的成员函数-析构函数来完成销毁工作的。如果当引用计数为0时，它的析构函数就会自动销毁对象，释放内存。</p>
<h3 id="shared_str自定义删除器"><code>shared_str</code>自定义删除器</h3><p>如果我们希望被销毁时，对指针不是单纯的进行<code>delete</code>操作，我们可以定义一个自己的删除器函数传给智能指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect(*p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other parameters */</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">connection c = connect(&amp;d);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</span><br><span class="line"><span class="comment">// use the connection</span></span><br><span class="line"><span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面的例子，当p被销毁时，我们会调用<code>end_connection</code>，来确保链接被关闭。这样即使在代码运行中发生异常，由于智能指针的特质，连接也一定会被关闭。</p>
<h2 id="unique_str"><code>unique_str</code></h2><p><code>unique_str</code>与<code>shared_str</code>不同的是，某个时刻只能有一个<code>unique_str</code>指向一个给定对象。当<code>unique_str</code>被销毁时，它所指向的对象也会被销毁。</p>
<h3 id="unique_ptr分配内存"><code>unique_ptr</code>分配内存</h3><p><code>unique_str</code>没有<code>make_shared</code>这样的标准库函数来返回动态指针。我们只能使用<code>new</code>进行直接初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">double</span>&gt; p1; </span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</span><br></pre></td></tr></table></figure>
<h3 id="unique_ptr拷贝与赋值"><code>unique_ptr</code>拷贝与赋值</h3><p>因为<code>unique_str</code>绑定了他指向的对象，所以她不能进行普通的拷贝或者赋值。我们只能调用<code>release</code>或者<code>reset</code>来转移指针的所有权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transfers ownership from p1 (which points to the string Stegosaurus) to p2</span></span><br><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p2(p1.release()); <span class="comment">// release makes p1 null</span></span><br><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Trex"</span>));</span><br><span class="line"><span class="comment">// transfers ownership from p3 to p2</span></span><br><span class="line">p2.reset(p3.release()); <span class="comment">// reset deletes the memory to which p2 had pointed</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现，利用<code>release</code>将切断<code>unique_ptr</code>和他所绑定对象的关系，返回的值可以用来初始化另一个<code>unique_ptr</code>。这样就达到了所有权转移的目的。</p>
<h3 id="unique_str自定义删除器"><code>unique_str</code>自定义删除器</h3><p><code>unique_str</code>自定义删除器和上面<code>shared_str</code>不同，我们必须在尖括号中<code>unique_str</code>指向类型后提供删除器类型。重写上面<code>shared_str</code>自定义删除器的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">connection c = connect(&amp;d); </span><br><span class="line"><span class="comment">// 当p被销毁时，连接将会被关闭</span></span><br><span class="line">unique_ptr&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt; p(&amp;c, end_connection);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使发生异常，连接也会被关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>decltype</code>返回的是一个函数类型，所以我们必须添加一个<code>*</code> 来指出我们该类型的一个指针。</p>
<h3 id="unique_str管理动态数组"><code>unique_str</code>管理动态数组</h3><p><code>unique_str</code>初始化动态数组的时候，我们要在对象类型后加一对空方括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up 指向一个包含10个非初始化int的数组</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line">up.release(); <span class="comment">// 自动调用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<p>当一个<code>unique_str</code>指向一个数组时，我们可以使用下标运算符来访问数组中的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">	up[i] = i;</span><br></pre></td></tr></table></figure>
<h1 id="allocator类"><code>allocator</code>类</h1><p><code>new</code>操作将内存分配和对象构造结合在一起，<code>delete</code>将对象析构和内存释放组合在一起。但是有的时候，我们希望将内存分配和对象构造分离。我们可以先分配大块内存，然后再真正需要时才执行对象创建操作。</p>
<h2 id="allocator分配内存"><code>allocator</code>分配内存</h2><p><code>allocator</code>是一个模板，为了定义一个对象，我们要指明这个<code>allocator</code>可以分配的对象类型。当一个<code>allocator</code>对象分配内存时，它会根据对象类型来确定恰当的内存大小。但是这些内存是未构造的，所以我们需要的时候，要构造相应的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc; </span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>
<h2 id="allocator构造对象"><code>allocator</code>构造对象</h2><p>我们可以使用<code>construct</code>来在未分配的内存初始化构造的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q 指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.construct(q++); <span class="comment">// *q is the empty string</span></span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, ’c’); <span class="comment">// *q is cccccccccc</span></span><br><span class="line">alloc.construct(q++, <span class="string">"hi"</span>); <span class="comment">// *q is hi!</span></span><br></pre></td></tr></table></figure>
<h2 id="allocator销毁对象"><code>allocator</code>销毁对象</h2><p>当我们用完对象后，我们需要销毁这个对象，对指向的对象执行析构函数。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(q != p)</span></span><br><span class="line">	alloc.destroy<span class="comment">(--q)</span>;</span><br></pre></td></tr></table></figure>
<p>我们需要用一个while循环，来不停的销毁对象，并且对q进行递减操作。这样能够保证所有构造元素都被销毁。销毁后，我们可以重新使用这部分内存来保存其他的<code>string</code>。</p>
<h2 id="allocator销毁内存"><code>allocator</code>销毁内存</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">alloc</span><span class="class">.deallocate</span>(<span class="tag">p</span>, <span class="tag">n</span>);</span><br></pre></td></tr></table></figure>
<p>我们传递给该函数的指针不能为空，必须指向由<code>allocate</code>分配的内存。而且传递给<code>deallocate</code>的大小参数必须和<code>allocate</code>分配内存时的大小一样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>c++ primer中第十二章：动态内存的笔记。]]>
    
    </summary>
    
      <category term="C++" scheme="http://prozhuchen.com/tags/C/"/>
    
      <category term="读书笔记" scheme="http://prozhuchen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://prozhuchen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="http://prozhuchen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ primer 笔记第七弹 - 类]]></title>
    <link href="http://prozhuchen.com/2017/01/19/c++primer_note7/"/>
    <id>http://prozhuchen.com/2017/01/19/c++primer_note7/</id>
    <published>2017-01-19T11:43:29.000Z</published>
    <updated>2017-01-19T11:47:09.600Z</updated>
    <content type="html"><![CDATA[<p>c++ primer中第七章：类的笔记。<a id="more"></a></p>
<h2 id="类中的this指针">类中的<code>this</code>指针</h2><p>在类中<code>this</code>是一个隐式参数，指向调用他的那个对象。因为<code>this</code>的目的是指向对象，所以<code>this</code>是一个常量指针，不能修改<code>this</code>中保存的地址。</p>
<p>在默认情况下，<code>this</code>是一个指向非常量的常量指针。例如类是<code>sale_data</code>,<code>this</code>指针的类型为<code>sale_data *const</code>。之前书上提到过，常量指针是不能绑定常量对象上的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a1 = &amp;p1; <span class="comment">// right</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a2 = &amp;p2; <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>
<p>所以如果想函数内部不改变对象的内容，则在函数后面加上<code>const</code>。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bookNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="c++11新标准-默认构造函数default">c++11新标准-默认构造函数<code>default</code></h2><p>当我们的类需要一个默认的构造函数时，我们可以使用如下的句式为类<code>sale_data</code>要求一个编译器自动生成的构造函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sales_data</span>() = <span class="default"><span class="keyword">default</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>如果上述句式出现在类内，默认构造函数是内联的。如果出现在类外，则不是内联的。</p>
<h2 id="定义类_-_class和struct">定义类 - <code>class</code>和<code>struct</code></h2><p>使用<code>class</code>和<code>struct</code>定义类的唯一区别就是默认访问权限不同。<code>class</code>默认是<code>private</code>，<code>struct</code>默认是<code>public</code>。</p>
<h2 id="可变数据成员_-_mutable">可变数据成员 - <code>mutable</code></h2><p>如果在某种情况下，你希望即使在一个const函数内，也要修改某个数据成员，你就在这个数据成员的声明前加上<code>mutable</code>关键字。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">class</span> <span class="tag">Screen</span> <span class="rules">&#123;</span><br><span class="line"><span class="rule"><span class="attribute">public</span>:<span class="value"></span><br><span class="line">void <span class="function">some_member</span>() const</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">private</span>:<span class="value"></span><br><span class="line">mutable size_t access_ctr</span></span>; </span><br><span class="line">&#125;</span>;</span><br><span class="line"><span class="tag">void</span> <span class="rule"><span class="attribute">Screen</span>:<span class="value">:<span class="function">some_member</span>() const</span><br><span class="line">&#123;</span><br><span class="line">++access_ctr</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述例子中，即使<code>some_member</code>函数是一个const函数，我们也可以修改<code>access_ctr</code>的值。</p>
<h2 id="返回*this的成员函数">返回<code>*this</code>的成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function">Screen &amp;<span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Screen &amp;Screen::<span class="built_in">set</span>(<span class="keyword">char</span> c)&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Screen &amp;Screen::display() <span class="keyword">const</span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上述例子，<code>set</code>函数返回的是调用set的对象的引用，这样我们可以将一系列操作链接成一句表达式。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myScreen.<span class="function"><span class="title">set</span><span class="params">(<span class="string">'1'</span>)</span></span>.<span class="function"><span class="title">set</span><span class="params">(<span class="string">'2'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到这个表达式等价于：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myScreen.<span class="keyword">set</span>(<span class="string">'1'</span>);</span><br><span class="line">myScreen.<span class="keyword">set</span>(<span class="string">'2'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果返回的是screen而不是screen&amp;，我们只能在*this上的拷贝副本进行<code>set(&#39;2&#39;)</code>，等价于：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Screen temp = myScreen.<span class="keyword">set</span>(<span class="string">'1'</span>);</span><br><span class="line">temp.<span class="keyword">set</span>(<span class="string">'2'</span>);</span><br></pre></td></tr></table></figure></p>
<p>而此时如果使用的是<code>display</code>函数，由于它是常量函数，所以返回的应该是<code>const Screen&amp;</code>，这时候下面的句子会出现问题。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myScreen.<span class="function"><span class="title">display</span><span class="params">()</span></span>.<span class="function"><span class="title">set</span><span class="params">(<span class="string">'2'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>因为此时<code>display</code>返回的是常量引用，而<code>set</code>无权对此操作。</p>
<p>##　友元</p>
<ol>
<li>友元类可以访问该类中的非公有成员，只需要在友元类声明的前面加上<code>friend</code>。</li>
<li>友元关系没有传递性，友元类的友元类不能也可以访问该类中的非公有成员。</li>
</ol>
<p>##　成员初始化的顺序</p>
<p>成员的初始化顺序与他们在类定义中的出现顺序一致，而与在构造函数的初始化列表顺序无关。</p>
<h2 id="聚合类和字面值常量类">聚合类和字面值常量类</h2><p>聚合类有如下特征：</p>
<ol>
<li>所有成员都是public的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类没，没有<code>virtual</code>函数。</li>
</ol>
<p>字面值常量类</p>
<ol>
<li>数据成员全是字面值类型。</li>
<li>至少含有一个<code>constexpr</code>构造函数。</li>
<li>类必须使用析构函数的默认定义。</li>
<li>如果一个数据成员含有类内初始值，则初始值必须是一条常量表达式。如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</li>
</ol>
<h2 id="静态static成员">静态<code>static</code>成员</h2><ol>
<li>静态成员不与任何对象绑定在一起，它属于整个类。</li>
<li>静态成员不包含<code>this</code>指针。</li>
<li>静态成员不能声明成<code>const</code>的。</li>
<li>不能在静态函数内使用this指针。</li>
<li>静态成员必须在类的外部定义和初始化。</li>
</ol>
<p>静态成员与非静态的一些试用场景区别：</p>
<ol>
<li>静态成员可以被类函数当做默认实参，而非静态成员不可以。因为非静态成员的值本身就属于对象的一部分。</li>
<li>静态成员的类型可以是他所属类的类型，但是非静态成员不可以。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>c++ primer中第七章：类的笔记。]]>
    
    </summary>
    
      <category term="C++" scheme="http://prozhuchen.com/tags/C/"/>
    
      <category term="读书笔记" scheme="http://prozhuchen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://prozhuchen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="http://prozhuchen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[调整youtube播放速度]]></title>
    <link href="http://prozhuchen.com/2017/01/10/slowdownyoutube/"/>
    <id>http://prozhuchen.com/2017/01/10/slowdownyoutube/</id>
    <published>2017-01-10T15:03:18.000Z</published>
    <updated>2017-01-10T15:09:45.709Z</updated>
    <content type="html"><![CDATA[<p>在youtube看英文视频时，语速太快听不懂啊，今天突然发现了一个在线自定义播放速度的方法。 <a id="more"></a></p>
<p>在播放视频界面点击F12调出开发者界面。</p>
<p>在<code>console</code>栏输入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.<span class="function"><span class="title">getElementsByTagName</span><span class="params">(<span class="string">"video"</span>)</span></span> [<span class="number">0</span>]<span class="class">.playbackRate</span> = <span class="number">0.5</span></span><br></pre></td></tr></table></figure></p>
<p>此时播放速度就是0.5倍啦，你想调成0.1都可以。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在youtube看英文视频时，语速太快听不懂啊，今天突然发现了一个在线自定义播放速度的方法。]]>
    
    </summary>
    
      <category term="其他" scheme="http://prozhuchen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="其他" scheme="http://prozhuchen.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网站改动-加入背景特效 & 自定义页面存放特定文章]]></title>
    <link href="http://prozhuchen.com/2017/01/05/%E7%BD%91%E7%AB%99%E6%94%B9%E5%8A%A8/"/>
    <id>http://prozhuchen.com/2017/01/05/网站改动/</id>
    <published>2017-01-05T06:38:29.000Z</published>
    <updated>2017-01-05T10:29:03.496Z</updated>
    <content type="html"><![CDATA[<p>今天突然发现next主题更新了好多东西，所以将自己网站的主题升级了，版本从0.4.5.1升到了5.1.0，并且做了一些改动。 <a id="more"></a></p>
<p>不是主题提供的改动如下：</p>
<h1 id="1-_加入了背景特效">1. 加入了背景特效</h1><p>这个主要是借鉴了这位博主的博客 <a href="http://jinfang.oschina.io/" target="_blank" rel="external">传送门</a>，觉得这样的背景特效很炫。所以也在自己的博客里加入。这位博主也有文章提到了如何加入该特效，我在这里只说明我的做法。</p>
<h2 id="1-1_特效文件保存本地">1.1  特效文件保存本地</h2><p>该特效是来自这个js文件提供的 <a href="http://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js" target="_blank" rel="external">传送门</a>。由于害怕未来这个地址失效，所以我们可以保存在本地。</p>
<p>在我们的<code>next\source\js\src</code>下，添加文件<code>canvas-nest.min.js</code>，将上述地址的内容拷贝进去。</p>
<h2 id="1-2_特效文件集成进next">1.2  特效文件集成进next</h2><ol>
<li><p>打开<code>next\layout\_layout.swig</code>，在之前添加如下代码（这点几乎完全是借鉴那个博主的）：</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template_tag">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; url_for(theme.js) &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">/src/canvas-nest.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  </span><span class="template_tag">&#123;% <span class="keyword">endif</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>\next\_config.yml</code>，加入下面的代码：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># --------------------------------------------------------------</span></span><br><span class="line"><span class="preprocessor"># background settings</span></span><br><span class="line"><span class="preprocessor"># --------------------------------------------------------------</span></span><br><span class="line"><span class="preprocessor"># add canvas-nest effect</span></span><br><span class="line"><span class="preprocessor"># see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line">canvas_nest: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此时我们在重新部署打开，就能看到最终效果啦。<img src="http://prozhuchen.com/images/webchange1.png" alt="image"></p>
</li>
</ol>
<h1 id="2-_将主题背景变透明">2. 将主题背景变透明</h1><p>加入了特效后，发现很多部分都被白色内容挡住了，把他们都移走！</p>
<p>打开<code>next\source\css\_schemes\Pisces\_layout.styl</code>（这里你要是其他的主题，就把地址里的<code>Pisces</code>换成对应主题名）</p>
<p>找到<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.content-wrap</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> $content-desktop-padding</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> $content-desktop</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">min-height</span>:<span class="value"> <span class="number">700px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> $box-shadow-inner</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> $border-radius-inner</span></span>;</span></span><br></pre></td></tr></table></figure></p>
<p>将<code>background: white;</code>去掉，加入如下内容：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) none repeat scroll <span class="number">0</span> <span class="number">0</span> <span class="important">!important</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#000000</span></span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">filter</span>:<span class="value"><span class="function">Alpha</span>(opacity=<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="rule"><span class="attribute">position</span>:<span class="value">static</span></span>; </span><br><span class="line">*<span class="rule"><span class="attribute">zoom</span>:<span class="value"><span class="number">1</span></span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此时的主页就变成了：<br><img src="http://prozhuchen.com/images/webchange2.png" alt="image"></p>
<h1 id="3-_自定义页面存放特定文章">3. 自定义页面存放特定文章</h1><p>因为我想在未来将一些读过的书的笔记单列成一项，对于读者也方便寻找，所以我自定义了<code>读书笔记</code>页面，里面只显示类别为读书笔记的文章。而且几乎所有的单独类别文章都可以这样列到首页啦。</p>
<h2 id="3-1_定义文章类别">3.1 定义文章类别</h2><p>这个只需要对新文章头部的<code>categories</code>部分进行填写即可，例如我希望将来显示读书笔记，这里就可以定义某一篇文章：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>读书笔记</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2_配置首页归档">3.2 配置首页归档</h2><p>在我们的<code>\next\_config.yml</code>下的<code>memu</code>项，加入对读书笔记项的配置：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">menu</span>:</span><br><span class="line">  <span class="attribute">home</span>: /</span><br><span class="line">  <span class="attribute">categories</span>: /categories</span><br><span class="line">  #<span class="attribute">about</span>: /about</span><br><span class="line">  <span class="attribute">archives</span>: /archives</span><br><span class="line">  <span class="attribute">tags</span>: /tags</span><br><span class="line">  <span class="attribute">readnotes</span>: /categories/读书笔记/</span><br></pre></td></tr></table></figure></p>
<h2 id="3-3_正确显示自定义项">3.3 正确显示自定义项</h2><p>我们可以发现，经过上面的定义，我们的首页项多了一个，但是不是正确的中文显示，所以我们需要配置对应中文的显示。</p>
<p>打开<code>next\languageszh-Hans.yml</code>。</p>
<p>在<code>memu</code>项下新加对于自定义页面的定义，这里我加入：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">readnotes</span>: <span class="string">读书笔记</span></span><br></pre></td></tr></table></figure></p>
<p>重新部署，我们发现显示正确啦，举一反三，以后自己的感想之类的都可以单独列出来啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天突然发现next主题更新了好多东西，所以将自己网站的主题升级了，版本从0.4.5.1升到了5.1.0，并且做了一些改动。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016CCF大赛-搜狗用户画像-经验分享]]></title>
    <link href="http://prozhuchen.com/2016/12/28/CCF%E5%A4%A7%E8%B5%9B%E6%90%9C%E7%8B%97%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://prozhuchen.com/2016/12/28/CCF大赛搜狗用户画像总结/</id>
    <published>2016-12-28T15:09:23.000Z</published>
    <updated>2017-03-05T11:46:54.546Z</updated>
    <content type="html"><![CDATA[<p>CCF大赛做了两个多月终于结束了，最后能拿到第五的成绩很意外也很高兴，毕竟第一次参加这种高规格的数据挖掘大赛，自己收获了很多。<a id="more"></a></p>
<p>在听取完前几名，包括其他比赛的答辩后，发现现在真是一个深度学习的时代。不管是在图像文本和其他领域，深度学习都表现出了比传统方法好很多的效果。队友戏言，我们是在没有用深度学习的团队中做的最好的，也算是对我们的一点安慰。</p>
<p>在这里对自己的之前两个月的成果做一点总结和思考吧。鉴于队友的博客<a href="https://coderskychen.github.io/2016/12/28/%E3%80%90%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB%E3%80%912016CCF%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%A4%A7%E8%B5%9B-%E6%90%9C%E7%8B%97%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%8C%96%E6%8E%98/" target="_blank" rel="external"> 传送门 </a>对于我们的整体模型已经讲得差不多了。这里对其算是一个补充和自己的一点感受吧，尽量不让大家感觉重复。</p>
<h1 id="1-_算法描述">1. 算法描述</h1><p>本题目提供用户历史一个月的查询词与用户的人口属性标签（包括性别、年龄、学历）做为训练数据，要求参赛人员通过机器学习、数据挖掘技术构建分类算法来对新增用户的人口属性进行判定。其中性别是二分类问题，年龄和学历都是六分类问题。数据集复赛为10w条数据。</p>
<h1 id="2-_整体流程概述">2. 整体流程概述</h1><h2 id="2-1_特征工程">2.1 特征工程</h2><h3 id="2-1-1_分词">2.1.1 分词</h3><ol>
<li>分词我们使用的是jieba分词包，从分词速度到精度都还不错。个人感觉想提高分词精度，一个好的自定义词典更加重要。</li>
<li>分词后处理部分，我们对停用词和单词的词性进行了过滤，只留下名词和动词。也是为了达到一种降维的目的吧。</li>
<li>最后的第一名大神考虑到了一点，他在分词时，保留了查询词条中的空格信息。他分析后认为博士词条空格数明显更多，是因为高学历者对于搜索引擎的使用更加熟练。这一点也得到了评委们的认可，在工业界的确也是这样处理的。</li>
</ol>
<h3 id="2-1-2_特征权重">2.1.2 特征权重</h3><p>文本分类的一个经典模型就是VSM模型。其中词-文档矩阵使用的特征权重就是TFIDF。我们在TFIDF中加入了类间差异信息，改进出了一个基于布尔模型的S-TFIWF算法。细节大家可以看这里<a href="https://coderskychen.github.io/2016/12/28/%E3%80%90%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB%E3%80%912016CCF%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%A4%A7%E8%B5%9B-%E6%90%9C%E7%8B%97%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E6%8C%96%E6%8E%98/" target="_blank" rel="external"> 传送门 </a>。</p>
<p>对于TFIDF的不足，在前几名中都没有对其进行改变。这算是我们的一点亮点。其实在国内外不少论文中，都有很多对于TFIDF的改进，所以大家在做文本分类的时候，也可以试着去使用一些改进的特征权重算法，或者使用我们的这个O(∩_∩)O~。</p>
<h3 id="2-1-3_特征选择">2.1.3 特征选择</h3><p>这里是我们本次比赛中可以算是最为纠结的的一点。尝试了多种特征选择算法，但是最后发现还是利用单词出现频率出现效果最好，这一点我们很惆怅。本来想在决赛中看看其他队伍的特征选择情况。然而他们是选择了融入其他种类特征，或者直接走深度学习。几乎没有做特征选择。所以，还是深度学习大法好啊。</p>
<h3 id="2-1-4_融入其他特征">2.1.4 融入其他特征</h3><p>在nlp领域，有两个很著名的特征：LDA和词向量(word2vec，doc2vec)。这两个特征同样可以表达出文本的特征信息，甚至比起TFIDF更好。详细的介绍大家可以百度一波。</p>
<p>在我们的使用中，我们是讲训练好的word2vec信息融入到了后来提到的分类模型中。在前几名的答辩中，都是同时使用了这两个特征，分别或者一起放到深度学习框架里进行训练。然后和正常的TFIDF特征一起进行集成学习。这点是我们差距很大的地方。</p>
<p>同时在后来和高君老师的聊天中，他也提到了目前搜狗的做法也是利用词向量特征直接放到深度学习框架中来做。不同的是，他们拥有着十分庞大的数据量，所以效果更加显著。</p>
<h2 id="2-2_分类模型">2.2 分类模型</h2><p>我们在比赛中最后使用的集成模型是stacking模型。这里详细介绍一下这个模型，算是对队友的一个补充。</p>
<p>经典Stacking模型是指将多种分类器组合在一起来取得更好表现的一种集成学习模型。一般情况下，Stacking模型分为两层。第一层中我们训练多个不同的模型，然后再以第一层训练的各个模型的输出作为输入来训练第二层的模型，以得到一个最终的输出。为了更加详细的阐述stacking模型的训练和预测过程，我们用下面的图作为示例。<br><img src="http://prozhuchen.com/images/stacking1.png" alt="经典stacking模型训练图"><br>首先，我们从stacking模型的训练开始阐述。在上图中我们可以看到，该模型的第一层有五个分类模型，第二层有一个分类模型。在第一层中，对于不同的分类模型，我们分别将训练数据分为 5 份，接下来迭代5次。每次迭代时，将 4 份数据作为训练集对每个分类模型进行训练，然后剩下一份数据在训练好的分类模型上进行预测并且保留结果。当5次迭代都完成以后，我们就获得了一个结果矩阵。该矩阵是一个N<em>1的矩阵，N是训练集的样本数。当5个模型都进行完上述操作后，我们就可以得到一个N</em>5的结果矩阵。然后将该矩阵导入到第二层的模型6中进行训练，此时全部模型训练完毕。接下来是stacking模型的预测过程。<br><img src="http://prozhuchen.com/images/stacking2.png" alt="经典stacking模型预测图"><br>接下来我们开始阐述该模型的预测过程。在第一层中，对于不同分类模型，我们还是使用在训练时分成的5份训练数据进行五次迭代。每次迭代时，我们利用训练后的分类模型对预测集进行预测并保留下来。当5次迭代都完成以后，我们可以得到一个M<em>5的矩阵，M是预测集的样本数。 我们将这个矩阵按列取平均，缩减成M</em>1的矩阵。当5个模型都进行完上述操作后，我们就可以得到一个M*5的结果矩阵。然后将该矩阵导入到第二层中训练好的模型6进行预测，就可以得到最终的预测结果。<br>    在介绍完经典stacking模型的训练及预测过程后，接下来阐述我们自己的stacking模型构建和改进。<br><img src="http://prozhuchen.com/images/stacking3.png" alt="改进后stacking模型训练图"><br>在模型训练过程中，模型第一层中的分类模型有25个。这其中包含了不同类型的分类器，和同一类型但是参数不同的分类器。增加这些分类器的原因是为了增加训练扰动，能够缓解分类模型的过拟合问题。在第二层中，我们使用了SVM分类器。同时我们加入了由词向量转变而成的文档向量矩阵，与第一层的训练结果进行特征拼接，拼接后的结果用来进行训练。加入词向量特征，可以引入词向量所含的语义信息。之所以加在第二层是因为第一层训练集特征的稀疏特性不适合与具有密集特性的词向量进行融合。<br><img src="http://prozhuchen.com/images/stacking4.png" alt="改进后stacking模型训练图"><br>在预测过程中，流程和训练过程相似，只是改成了用预测集在训练好的分类模型上进行预测。我们注意到，在Stacking模型中，由于在第一层的预测过程也需要使用第一层时的数据划分，所以一般Stacking模型的运行顺序是：</p>
<ol>
<li>第一层训练</li>
<li>第一层预测</li>
<li>第二层训练</li>
<li>第二层预测</li>
</ol>
<p>至此，我们改进后的stacking模型介绍完毕。</p>
<p>下面谈一下自己使用过程中的感受吧。</p>
<ol>
<li>在sklearn中也是有集成模型的。但是他只有boosting和bagging的集成模型代码。可能还是因为stacking模型的灵活性太高了吧。</li>
<li>我们在第一层的模型选择上，主要是考虑到了速度问题，所以选取的都是一些线性分类器和速度比较快的线性核svm等。第二层我们使用的是rbf核SVM。但是在第二层的特征数由于加入了词向量特征而变大后，第二层的训练预测时间变得很长。所以SVM好，但是使用需谨慎啊。</li>
<li>对于xgboost模型，我们在和svm比较后，发现比不过svm分类器。同时xgboost的调参也是一个蛮长的贪心过程。所以我们没有使用xgboost。但是在答辩中，前几名的大神在集成模型上几乎都用到了xgboost。这也说明xgboost的效果还是非常好的。</li>
<li>stacking模型理论上可以扩大到无数层。但是在答辩过程中，发现大家都是只使用了两层，同时我们也实验了搭出三层的stacking，效果也不如两层的。</li>
<li>在一开始的时候，我们只在第一层中放入了四个分类器，但是受到了一些博客的影响，我们开始尝试加入更多的分类器。第一种是不同类型的分类器，但是更多的是同类型，但是不同参数下的分类器。我们发现，分类器越多时，最终效果更好。但是随着分类器的增多，效果提升的越来越少。但是这不失为是一个刷分的好方法。</li>
</ol>
<h1 id="3-_赛后总结">3. 赛后总结</h1><ol>
<li>在比赛过程中，我们发现，想做到前50，就去多看大神博客。但是想做到前5，还是需要阅读一些这方面的论文进行思想上面的补充的。</li>
<li>由于我们做的是文本方面的问题，还有看到了一些图像方面的问题。深度学习都已经是主流的解决方法。但是我们也看到在一些传统的以特征工程为主的问题解决中，还是有不少都是利用传统的数据挖掘算法进行解决的。所以不能盲目迷信深度学习，也是要分情况讨论的。</li>
<li>不管在什么问题上，对于数据的分析都是十分重要的。这也是评委老师们十分看重的一点。毕竟大家的整体模型不会有很大差距，差距的所在很多情况下都是在对数据的分析上。</li>
<li>如果你是一个比赛小白，还是需要找一个靠谱的团队，不论是从哪个方面都能帮助你很多。当然也是有很多solo大神，这里只能膜拜了。</li>
<li>一个小建议：如果你答辩紧张，可以事先背演讲稿O(∩_∩)O哈哈~，亲测有用。</li>
</ol>
<h1 id="4-_代码">4. 代码</h1><p>代码和答辩PPT已经公开 <a href="https://github.com/prozhuchen/2016CCF-sougou" target="_blank" rel="external">传送门</a>。在coding的过程中，也阅读了一些源码，发现自己的代码写的还是比较low的。在接下来有时间我准备把分类模型stacking这块的代码重构一下，尽量能够达到可复用的目标吧。</p>
<p>这里给大家一些自己的看法：</p>
<ol>
<li>尽量能让自己的代码达到模块化，不管在后期修改和阅读中都有很大好处。在这里我们吃了很大的亏。</li>
<li>多阅读一些比较著名的源码。真的会对我们有很大帮助。</li>
</ol>
<p>python数据挖掘包集合总结：</p>
<ul>
<li>基础包：numpy,scipy</li>
<li>大神级数据挖掘包：sklearn</li>
<li>数据可视化：pandas</li>
<li>数据不均衡：imbalanced-learn</li>
<li>大神级nlp包：gensim（word2vec和LDA）</li>
<li>深度学习包：TensorFlow</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>CCF大赛做了两个多月终于结束了，最后能拿到第五的成绩很意外也很高兴，毕竟第一次参加这种高规格的数据挖掘大赛，自己收获了很多。]]>
    
    </summary>
    
      <category term="数据挖掘" scheme="http://prozhuchen.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="数据挖掘" scheme="http://prozhuchen.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL源码剖析之第二章：空间配置器]]></title>
    <link href="http://prozhuchen.com/2016/08/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://prozhuchen.com/2016/08/26/STL源码剖析之第二章：空间配置器/</id>
    <published>2016-08-26T08:42:34.000Z</published>
    <updated>2017-01-19T11:46:30.037Z</updated>
    <content type="html"><![CDATA[<h1 id="1-_空间配置器">1. 空间配置器</h1><blockquote>
<p>空间配置器：是对空间进行分配和处理的部分。是空间而不是内存的原因是因为空间也可以是磁盘等其他介质。</p>
</blockquote>
<ol>
<li><p>SGI STL的配置器是alloc而不是allocator，而且不接受任何参数。</p>
</li>
<li><p>SGI STL对于标准的配置器只做了一层简单包装，且不推荐我们使用。</p>
</li>
<li><p>在一般使用类的动态内存申请时，我们使用的new和delete其实都分为两步：</p>
<ul>
<li>new首先调用operator new 配置内存</li>
<li>new然后调用类的构造函数构造对象。</li>
<li>delete首先调用类的析构函数析构对象。</li>
<li>delete然后调用operator delete 释放内存</li>
</ul>
</li>
<li><p>SGI STL的new和delete：</p>
<ol>
<li><p>内存配置由alloc::allocate()负责。</p>
</li>
<li><p>内存释放由alloc::deallocate()负责。</p>
</li>
<li><p>对象构造由::construct()负责。</p>
</li>
<li><p>对象析构由::destroy()负责。</p>
</li>
</ol>
</li>
</ol>
<h2 id="1-1_构造和析构：construct,destroy">1.1 构造和析构：construct,destroy</h2><p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A81.png" alt=""></p>
<h2 id="1-2_空间的配置和释放::alloc">1.2 空间的配置和释放::alloc</h2><p>SGI对于空间配置的设计哲学如下：</p>
<blockquote>
<p>向system heap要求空间</p>
<p>考虑多线程</p>
<p>考虑内存不足时的应变措施</p>
<p>考虑小区块带来的内存碎片问题</p>
</blockquote>
<p>考虑到小区快带来的内存破碎问题，SGI设计了双层级配置器。</p>
<p>第一级配置器：直接使用C中的malloc和free。</p>
<p>第二级配置器：视情况不同，配置区块大于128byte时，调用第一级；小于128byte，采用更复杂的内存池 模式。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A82.png" alt=""><br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/空间配置器3.png" alt=""></p>
<h2 id="1-3_第一级配置器剖析">1.3 第一级配置器剖析</h2><ol>
<li>SGI其实是直接使用了c中的<code>malloc</code>和<code>free</code>。</li>
<li>SGI不使用c++的new,而是使用c的<code>malloc</code>,有一部分原因是因为c++中没有提供<code>realloc</code>的功能。</li>
<li>但是当出现内存配置出现问题时，SGI又会仿照C ++ 实现一个new-handler机制。不能直接使用c++的该机制的原因是，它没有使用new来配置内存，所以无法直接使用这个c ++ 的特定机制，只能仿真一个类似的。</li>
<li>当第一级配置器的<code>allocate（）</code>和<code>realloc（）</code>不成功时，它会调用<code>oom_malloc（）</code>和<code>oom_realloc（）</code>函数（oom代表<code>out of memory</code>），这两个函数内部都是一个内循环，不断调用“内存不足处理例程”。</li>
<li>注意一点的是，上述的内存不足处理例程由调用者自己设计，如果没有被设定，配置器会直接丢出<code>BAD_AALOC</code>异常。</li>
</ol>
<h2 id="1-4_第二级配置器剖析">1.4 第二级配置器剖析</h2><p>第二级配置器的存在就是为了解决小区块内存带来的内存碎片化和配置时带来的额外负担。</p>
<blockquote>
<p>额外负担是指，当每一个区块内存被分配的时侯，他都需要一部分额外内存来纪录该块内存的大小，这一块纪录内存属于额外负担。</p>
</blockquote>
<p>第二级配置器对于内存配置的做法是：<br>区块大于128byte时，移交给第一级配置器处理。<br>区块小于128byte时，使用内存池进行管理。</p>
<h3 id="1-4-1_内存池管理">1.4.1 内存池管理</h3><p>内存池每次的配置一大块内存，然后用一个freelist来进行维护。有内存需求则从freelist拨出，如果释放则有freelist收回。为了方便管理，SGI会将小区块的内存需求调整到8的倍数。这样一来，有8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128，总共16个freelist。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A84.png" alt=""></p>
<blockquote>
<p>上调到8的倍数实现：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">enum</span> &#123;__ALIGN=<span class="number">8</span>&#125;;</span><br><span class="line">&#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN-<span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN – <span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>free_list:为了节省空间，obj的结构是一个union类型。也就是说，当该区块给用户的时候，obj是一个指向实际区块的指针，当给系统时候，obj是一个指向下一个节点的指针。这个可以节省内存的开销。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span>* <span class="title">free_list_link</span>;</span></span><br><span class="line">    char client_data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="1-4-2_空间配置函数allocate()">1.4.2 空间配置函数allocate()</h3><p>区块大于128byte时，移交给第一级配置器处理。<br>区块小于128byte时，在freelist中找可用区块，有则调用；没有则上调至8倍数边界，调用refill()来填充空间。</p>
<h3 id="1-4-3_空间释放函数deellocate()">1.4.3 空间释放函数deellocate()</h3><p>区块大于128byte时，移交给第一级配置器处理。<br>区块小于128byte时，找出对应区块，进行回收。</p>
<h3 id="1-4-4_重新填充free_list函数refill()">1.4.4 重新填充free_list函数refill()</h3><p>当allocate()发现没有freelist没有区块的时候，就调用refill()，refill()从内存池中取出内存重新填充freelist。默认取得20个新区快，但是当内存池不够时，获得的会小于20.</p>
<h3 id="1-4-5_从内存池取内存函数chunk_alloc()">1.4.5 从内存池取内存函数chunk_alloc()</h3><p>chunk_alloc()通过两个指针：end_free和start_free的差值来判断内存池的剩下空间。</p>
<ol>
<li>空间&gt;20区块空间：调出20个区块空间给freelist.</li>
<li>1区块空间&lt;空间&lt;20区块空间：调出能调出的空间出来。</li>
<li>空间&lt;1区块空间：使用malloc()从系统中申请内存，然后拨给freelist。新申请的量是需求量的两倍，加上一个随着配置次数增加不断变大的附加量。</li>
<li>特殊情况（系统内存不够，malloc失败）：chunk_alloc()开始寻找freelist中未被使用的够大的区块，找到了就拿走一块；找不到就调用第一级配置器。第一级配置器虽然使用也是malloc，但是有out-of-memory机制，可以有机会释放其他内存来使用。</li>
</ol>
<h2 id="1-5_内存基本处理工具">1.5 内存基本处理工具</h2><p>对于未初始化的空间，STL的处理工具有五个：<br><code>construct(),destroy(),uninitialized_copy(),uninitialized_fill(),uninitialized_fill_n()</code><br>其中<code>uninitialized_copy(),uninitialized_fill(),uninitialized_fill_n()</code>分别对应STL算法中的<code>copy() ,fill(),fil_n()</code>。<br>C++规格要求这三个函数具有<code>commit or rollback</code>语意。意思是要么就构造出所有必要元素。要么不构造任何东西。（很像数据库中的原子性）</p>
<h3 id="1-5-1_uninitialized_copy()">1.5.1 uninitialized_copy()</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">InputIterator</span>, class <span class="type">ForwardIterator</span>&gt;</span><br><span class="line"><span class="type">ForwardIterator</span> uninitialized_copy ( <span class="type">InputIterator</span> first, <span class="type">InputIterator</span> last,<span class="type">ForwardIterator</span> <span class="literal">result</span> )</span><br></pre></td></tr></table></figure>
<p>该函数将[first，last)的值复制到[result，result+(last-first))。<br>该函数在容器上的作用：容器的构造函数通常以两个步骤完成：</p>
<ul>
<li>配置复制所需的内存区块。</li>
<li>使用uninitialized_copy()，在该内存区块上构造元素。</li>
</ul>
<h3 id="1-5-2_uninitialized_fill()">1.5.2 uninitialized_fill()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">uninitialized_fill</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果[first，last)范围内的迭代器都指向未初始化的内存，那么该函数将会在该范围内产生x的复制品。</p>
<h3 id="1-5-3_uninitialized_fill_n()">1.5.3 uninitialized_fill_n()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">uninitialized_fill_n</span> <span class="params">(ForwardIterator first, Size n, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果[first，first+n)范围内的迭代器都指向未初始化的内存，那么该函数将会在该范围内产生x的复制品。</p>
]]></content>
    <summary type="html">
    <![CDATA[STL源码剖析第二章：空间配置器笔记]]>
    
    </summary>
    
      <category term="C++" scheme="http://prozhuchen.com/tags/C/"/>
    
      <category term="读书笔记" scheme="http://prozhuchen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://prozhuchen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++" scheme="http://prozhuchen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客小知识：更改背景颜色]]></title>
    <link href="http://prozhuchen.com/2016/07/10/Hexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86%EF%BC%9A%E6%9B%B4%E6%94%B9%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/"/>
    <id>http://prozhuchen.com/2016/07/10/Hexo博客小知识：更改背景颜色/</id>
    <published>2016-07-10T03:27:05.000Z</published>
    <updated>2016-07-10T04:20:26.641Z</updated>
    <content type="html"><![CDATA[<p>最近发现有读者在问这个博客的背景颜色是怎么做出来的，这里单独写出来解答一下吧。</p>
<p>更改背景颜色这种的事情是通过css来控制的，具体的文件是<code>hexo/public/css</code>下的<code>main.css</code>来定义的。下面是页面上两处颜色的定义。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*首页头部的颜色设置*/</span></span><br><span class="line"><span class="class">.header</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#d1fab8</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="comment">/*主体部分的颜色设置*/</span></span><br><span class="line"><span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#e0fccf</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们只需要更改上述的两个背景颜色，就可以获得我们想要的颜色效果。<br>那如何获得我们想要的颜色代码呢？最简单的一种方法就是使用chrome上的颜色抓取器。或者可以参照<a href="http://www.114la.com/other/rgb.htm/" target="_blank" rel="external">RGB颜色查询对照表</a>。</p>
<p>其实只要我们懂得简单的css和js，我们就可以更改任何我们想更改的部分啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[我们来看看如何更改博客的背景颜色。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[opencv小练习：哈尔小波(haar)]]></title>
    <link href="http://prozhuchen.com/2016/07/07/opencv%E5%B0%8F%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%93%88%E5%B0%94%E5%B0%8F%E6%B3%A2(haar)/"/>
    <id>http://prozhuchen.com/2016/07/07/opencv小练习：哈尔小波(haar)/</id>
    <published>2016-07-07T02:44:21.000Z</published>
    <updated>2016-08-24T07:22:30.591Z</updated>
    <content type="html"><![CDATA[<p>首先说一下一维haar小波的原理。<br>例如我们有一个一维的图像[2,4,6,8,10,12,14,16].</p>
<ol>
<li>求均值：我们求相邻像素的均值[3,7,11,15]。这个新的图像分辨率就成了原来的一半(8/2=4)。</li>
<li>求差值。上面的均值我们存储了图像的整体信息。但是很多细节信息我们丢掉了，所以我们同时要记录图像的细节信息，这样在重构时能够恢复图像的全部信息。下面是求第m个差值的公式：</li>
</ol>
<p>$$b[m]=(a[2m]-a[2m+1])/2$$<br>经过计算我们得到了结果[-1,-1,-1,-1]。这个新的分辨率也成了原来的一半(8/2=4)。</p>
<ol>
<li>此时上面两步形成了第一次分解的结果[3,7,11,15,-1,-1,-1,-1]。包含了图像的整体信息和细节信息。接下来的分解我们重复1,2步，将整体信息再次进行分解，得到了二级分解结果[5，13，-2，-2].同样的，前面的[5,13]是整体信息，后面的[-2,-2]是细节信息。</li>
</ol>
<table>
<thead>
<tr>
<th>分辨率</th>
<th style="text-align:center">整体信息</th>
<th style="text-align:center">细节信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td style="text-align:center">3,7,11,15</td>
<td style="text-align:center">-1,-1,-1,-1</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">5，13</td>
<td style="text-align:center">-2，-2</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">9</td>
<td style="text-align:center">-4</td>
</tr>
</tbody>
</table>
<p>经过三次分解，我们得到了一个整体信息和三个细节系数，这个就是一维小波变换。</p>
<p>对于二维haar小波，我们通常一次分解形成了整体图像，水平细节，垂直细节，对角细节。首先我们按照一维haar小波分解的原理，按照行顺序对行进行处理，然后按照列顺序对行处理结果进行同样的处理。最后形成了如下的形式。<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/%E5%93%88%E5%B0%94%E5%B0%8F%E6%B3%A2%28haar%29.jpg" alt=""></p>
<p>  cpp代码（opencv版本：opencv3.0）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span><br><span class="line">Copyright:zhuchen</span><br><span class="line">Author: zhuchen</span><br><span class="line">Date:2016-01-10</span><br><span class="line">Description:多级haar小波变换</span><br><span class="line">**************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># <span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat img = imread(<span class="string">"lenna.bmp"</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> Height = img.cols;</span><br><span class="line">	<span class="keyword">int</span> Width = img.rows;</span><br><span class="line">	<span class="keyword">int</span> depth = <span class="number">3</span>;    <span class="comment">//定义分解深度</span></span><br><span class="line">	<span class="keyword">int</span> depthcount = <span class="number">1</span>; </span><br><span class="line">	Mat tmp = Mat::ones(Width, Height, CV_32FC1);</span><br><span class="line">	Mat wavelet = Mat::ones(Width, Height, CV_32FC1);</span><br><span class="line">	Mat imgtmp = img.clone();</span><br><span class="line">	imgtmp.convertTo(imgtmp, CV_32FC1);</span><br><span class="line">	<span class="keyword">while</span> (depthcount&lt;=depth)&#123;</span><br><span class="line">		Width = img.rows / depthcount;</span><br><span class="line">		Height = img.cols / depthcount;</span><br><span class="line">		<span class="keyword">int</span> step = <span class="number">2</span> * depthcount;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Width; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Height / <span class="number">2</span>; j++)&#123;</span><br><span class="line">				tmp.at&lt;<span class="keyword">float</span>&gt;(i, j) = (imgtmp.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span> * j) + imgtmp.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span> * j + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">				tmp.at&lt;<span class="keyword">float</span>&gt;(i, j + Height / <span class="number">2</span>) = (imgtmp.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span> * j) - imgtmp.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span> * j + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Width / <span class="number">2</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Height; j++)&#123;</span><br><span class="line">				wavelet.at&lt;<span class="keyword">float</span>&gt;(i, j) = (tmp.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span> * i, j) + tmp.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span> * i + <span class="number">1</span>, j)) / <span class="number">2</span>;</span><br><span class="line">				wavelet.at&lt;<span class="keyword">float</span>&gt;(i + Width / <span class="number">2</span>, j) = (tmp.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span> * i, j) - tmp.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span> * i + <span class="number">1</span>, j)) / <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		imgtmp = wavelet;</span><br><span class="line">		depthcount++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	namedWindow(<span class="string">"jpg"</span>,<span class="number">0</span>);</span><br><span class="line">	wavelet.convertTo(wavelet, CV_8UC1);</span><br><span class="line">	wavelet += <span class="number">50</span>;            <span class="comment">//图像暗度过低，所以这里我加了50</span></span><br><span class="line">	imshow(<span class="string">"jpg"</span>, wavelet);</span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[闲来无聊，写一个小练习]]>
    
    </summary>
    
      <category term="Opencv" scheme="http://prozhuchen.com/tags/Opencv/"/>
    
      <category term="Opencv" scheme="http://prozhuchen.com/categories/Opencv/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux读书笔记(1)]]></title>
    <link href="http://prozhuchen.com/2016/04/14/linux%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/"/>
    <id>http://prozhuchen.com/2016/04/14/linux读书笔记(1)/</id>
    <published>2016-04-14T02:42:16.000Z</published>
    <updated>2016-07-09T17:47:53.955Z</updated>
    <content type="html"><![CDATA[<p>这篇文章主要讲的是linux的文件和目录方面的。</p>
<h2 id="1-_用户和用户组">1. 用户和用户组</h2><p>每一个文件属于一个用户，而每一个用户会属于一个或多个用户组，而系统内会有多个用户组。有些文件用户组之间可以共享，而有些文件被设置成用户个人文件，即使是用户组内的其他用户也不能去读或写。这样的设置使linux下的多任务管理更加简单。<br>在我们的linux系统下，默认所有用户和root的相关信息都记录在了/etc/passwd里面。个人的密码记录在/etc/shadow里，而linux内所有的组名都记录在/etc/group内。</p>
<h2 id="2-_linux的文件属性和权限">2. linux的文件属性和权限</h2><p>linux下的文件构造可以通过<code>ls -al</code>查看，<code>-a</code>是指所有的文件（包括隐藏文件），<code>-l</code>是指文件信息会以列表格式展现出来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~$ ls -al</span><br><span class="line"></span><br><span class="line">drwxr-xr-x <span class="number">32</span> zhuchen root        <span class="number">4096</span>  <span class="number">4</span>月 <span class="number">14</span> <span class="number">18</span>:<span class="number">04</span> .</span><br><span class="line">drwxr-xr-x  <span class="number">5</span> root    root        <span class="number">4096</span>  <span class="number">3</span>月 <span class="number">16</span> <span class="number">10</span>:<span class="number">50</span> ..</span><br><span class="line">drwx------  <span class="number">3</span> zhuchen root        <span class="number">4096</span>  <span class="number">3</span>月 <span class="number">15</span> <span class="number">09</span>:<span class="number">49</span> .adobe</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zhuchen root       <span class="number">25283</span>  <span class="number">7</span>月 <span class="number">17</span>  <span class="number">2015</span> ascii_dora.png</span><br><span class="line">-rw-------  <span class="number">1</span> zhuchen zhuchen    <span class="number">13641</span>  <span class="number">4</span>月 <span class="number">14</span> <span class="number">17</span>:<span class="number">19</span> .bash_history</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zhuchen root         <span class="number">220</span>  <span class="number">3</span>月 <span class="number">14</span> <span class="number">17</span>:<span class="number">34</span> .bash_logout</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zhuchen root        <span class="number">3771</span>  <span class="number">3</span>月 <span class="number">14</span> <span class="number">17</span>:<span class="number">34</span> .bashrc</span><br><span class="line">drwxr-xr-x <span class="number">20</span> zhuchen root        <span class="number">4096</span>  <span class="number">3</span>月 <span class="number">30</span> <span class="number">15</span>:<span class="number">16</span> .cache</span><br><span class="line">drwx------ <span class="number">26</span> zhuchen root        <span class="number">4096</span>  <span class="number">4</span>月  <span class="number">7</span> <span class="number">18</span>:<span class="number">17</span> .config</span><br><span class="line">drwx------  <span class="number">3</span> zhuchen root        <span class="number">4096</span>  <span class="number">3</span>月 <span class="number">14</span> <span class="number">19</span>:<span class="number">26</span> .dbus</span><br><span class="line">drwxr-xr-x  <span class="number">2</span> zhuchen root        <span class="number">4096</span>  <span class="number">3</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">29</span> Desktop</span><br></pre></td></tr></table></figure></p>
<p>首先解读一下每列字段的意义。<br>第一列代表这个文件的类型和权限。具体含义我们后面再说。<br>第二列代表有多少文件名连接到此节点（i-node）。<br>第三列代表文件（目录）所有者（用户）的账号。<br>第四列代表文件（目录）所属的用户组。<br>第五列代表文件（目录）的大小，默认单位为B。<br>第六列代表文件（目录）的修改日期（未修改过则是创建日期）。<br>第七列代表文件（目录）的名字。</p>
<p>下面我们重点解读一下第一列字符串，文件权限和类型的含义。以<code>drwxr-xr-x</code>为例子。<br>第一个字符代表这个是目录，文件还是别的。</p>
<ul>
<li>[d]：目录</li>
<li>[-]: 文件</li>
<li>[|]: 连接文件（linkfile）</li>
<li>[b]: 设备文件里可供存储的接口设备。</li>
<li>[c]：设备文件里的串行接口设备（键盘，鼠标）。</li>
</ul>
<p>例子中的第一个字符是d，也就是文件。</p>
<p>后面的字符每三个一组总共三组。第一组为’文件所有者的权限’，第二组为’一个用户组内其他用户的权限’，第三组为’不同用户组的用户的权限’。<br>而每一组里有三个字符，第一个r代表可读，第二个w代表可写，第三个x代表可执行。这三个权限的位置不会改变，当没有这个权限的时候，该位置用-表示。<br>例子中的<code>rwxr-xr-x</code>分为三组：</p>
<ol>
<li>第一组<code>rwx</code>说明文件所有者对该文件可读，可写，可执行。</li>
<li>第二组<code>r-x</code>说明同用户组内其他用户对该文件可读，不可写，可执行。</li>
<li>第三组<code>r-x</code>说明不同用户组的其他用户对该文件可读，不可写，可执行。</li>
</ol>
<h2 id="3-_改变文件的属性和权限">3. 改变文件的属性和权限</h2><p>chgrp:改变文件用户组<br>chown:改变文件所有者<br>chmod:改变文件权限</p>
<p>linux每个文件的基本权限有九个，分别是owner，group，other三种身份各有自己的三个权限（rwx）。而这9个权限是三个一组的。其中，我们用数字来代表各个权限。r:4，w:2，x:1。我们这里拿<code>rwxrw-r-x</code>举例<br>owner = rwx = 4+2+1 = 7<br>group = rw- = 4+2+0 = 6<br>other = r-x = 4+0+1 = 5</p>
<p>所以我们可以看出，如果要是想将这个文件的权限改为<code>-rw-r--r--</code>，就可以用 <code>chmod 644 filename</code>。</p>
<h2 id="4-权限对于文件和目录的作用">4.权限对于文件和目录的作用</h2><p>文件：</p>
<p>r:可以读取文件的实际内容。<br>w:可以编辑，新增和修改内容，但是不能删除。<br>x:可以被系统执行的权限。<br>至于w权限为什么不可以删除该文件，是因为这里的rwx权限都是对于文件本身的内容来说的，而不是文件的存在。</p>
<p>目录：</p>
<p>r:可以读取该目录结构列表的权限。也就是可以用ls这个命令了。<br>w:表示你可以更改该目录结构的权限。即：</p>
<ul>
<li>新建新的文件和目录</li>
<li>删除存在的文件和目录</li>
<li>重命名存在的文件和目录</li>
<li>转移存在的文件和目录</li>
</ul>
<p>x:表示用户能否进入该目录成为工作目录的权限。所谓的工作目录就是你目前所做的目录。也就是你能用<code>cd</code>将转变目前的工作目录成该目录的权限。</p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章主要讲的是linux的文件和目录方面的。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://prozhuchen.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://prozhuchen.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[matplotlib更改字体以及支持中文问题]]></title>
    <link href="http://prozhuchen.com/2016/02/20/matplotlib%E6%9B%B4%E6%94%B9%E5%AD%97%E4%BD%93%E4%BB%A5%E5%8F%8A%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>http://prozhuchen.com/2016/02/20/matplotlib更改字体以及支持中文问题/</id>
    <published>2016-02-20T02:48:00.000Z</published>
    <updated>2016-07-09T17:22:27.461Z</updated>
    <content type="html"><![CDATA[<p>在使用matplotlib的时候，发现了matplotlib无法支持中文的一个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">u'测试程序'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u'x轴'</span>)</span><br><span class="line">plt.ylabel(<span class="string">u'y轴'</span>)</span><br><span class="line">plt.grid(<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果图：<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/matplotlib%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%871.png" alt=""></p>
<p>有两个方法解决他：</p>
<ol>
<li>直接在开头时改变整个脚本的显示字体：<code>matplotlib.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]</code> 当然这个SimHei是可以自己改的。<br> 例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">matplotlib.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">u'测试程序'</span>)</span><br><span class="line">plt.xlabel(<span class="string">u'x轴'</span>)</span><br><span class="line">plt.ylabel(<span class="string">u'y轴'</span>)</span><br><span class="line">plt.grid(<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>结果图：<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/matplotlib%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%872.png" alt=""></p>
<ol>
<li>也可以动态的决定每个显示时的字体：<br>例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">font = matplotlib.font_manager.FontProperties(fname=<span class="string">'C:\Windows\Fonts\simsun.ttc'</span>)</span><br><span class="line">font1 = matplotlib.font_manager.FontProperties(fname=<span class="string">'C:\Windows\Fonts\mingliu.ttc'</span>)</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(<span class="string">u'测试程序'</span>,fontproperties=font1)</span><br><span class="line">plt.xlabel(<span class="string">u'x轴'</span>, fontproperties=font)</span><br><span class="line">plt.ylabel(<span class="string">u'y轴'</span>, fontproperties=font)</span><br><span class="line">plt.grid(<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>结果图：<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/matplotlib%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%873.png" alt=""></p>
<p>这个图里的’测试程序’和’x轴’是两种字体，也就是说我们可以任意改变每一个label的字体啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[matplotlib怎么来支持中文呢？]]>
    
    </summary>
    
      <category term="Python" scheme="http://prozhuchen.com/tags/Python/"/>
    
      <category term="Python" scheme="http://prozhuchen.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性预测linear prediction]]></title>
    <link href="http://prozhuchen.com/2015/12/06/%E7%BA%BF%E6%80%A7%E9%A2%84%E6%B5%8Blinear%20prediction/"/>
    <id>http://prozhuchen.com/2015/12/06/线性预测linear prediction/</id>
    <published>2015-12-05T17:56:51.000Z</published>
    <updated>2016-12-30T13:04:13.030Z</updated>
    <content type="html"><![CDATA[<p>线性预测是一种利用之前样品的线性函数来估计未来离散时间信号的值的数学运算方式。</p>
<p>在数字信号处理中,线性预测通常被称为线性预测编码(LPC),因此可以视为滤波器理论的一个子集。在系统分析(数学的一个分支)中,线性预测可以看作是数学建模或者是优化问题的一部分。</p>
<h1 id="1-_预测模型">1. 预测模型</h1><p>最普通的线性预测表达式是<br><img src="https://upload.wikimedia.org/math/2/9/8/298ffd65763de57f54b00265e4eab093.png" alt=""><br>这里的$\widehat{x}(n)$是预测的信号值，$x(n-i)$是之前获得的值，${a}<em>{i}$是预测系数，估计所产生的误差是<br><img src="https://upload.wikimedia.org/math/6/c/4/6c4e327c077c8a75dfe2e5bce093f93f.png" alt=""><br>这里的$x(n)$是正确的信号值。<br>这些方程对于所有类型的一维线性预测都是有效的。对于不同的方法其所不同的是参数 ${a}</em>{i}$ 的选择。<br>对于多维信号而言，误差指标一般被定义为</p>
<p><img src="https://upload.wikimedia.org/math/9/8/f/98f0d06152b1ae8c7abd335b03915fa6.png" alt=""><br>这里的$\left | . \right |$是一个合适的向量范数。预测函数（$\widehat{x}(n)$）通常使用卡尔曼滤波器和平滑来分别估计当前和过去的信号。</p>
<h1 id="2-_估计参数">2. 估计参数</h1><p>对于优化参数 $\widehat{x}(n)$，最常见的选择是均方根标准，也被称为自相关性准则。在这个方法中,我们使平方误差<img src="https://upload.wikimedia.org/math/7/6/f/76f77ec3a84efce98d1be71aec2b1f5c.png" alt="">的期望值最小化,得到的公式是</p>
<p><img src="https://upload.wikimedia.org/math/8/6/4/864e5aebb65c00bb7d5f73de63ebdbc1.png" alt=""> 1 ≤ j ≤ p<br>这里的R是信号<code>x(n)</code>的自相关性。定义是：<br><img src="https://upload.wikimedia.org/math/5/0/5/5056382e606158a997e377f49fc58ada.png" alt=""><br>这里的 $E$ 是期望值。在多维情况中，这个对应于L2范数的最小化。<br>上面的方程称为normal方程或者Yule-Walker方程。该方程在矩阵形式中可以等价于<br>$Ra=-r$<br>这里的自相关矩阵R是对称的，$p*p$的<code>Toeplitz</code>矩阵，其元素<img src="https://upload.wikimedia.org/math/e/3/b/e3bace5f06f9153be1a1c1b0dbd56c8e.png" alt="">，向量$a$是一个参数向量。<br>另一个更一般的做法是尽可能降低在公式中定义的误差平方和<br><img src="https://upload.wikimedia.org/math/a/f/7/af76053e4e83b5d30280ef9c2ca136ec.png" alt=""><br>其中对于所有$a_i$的最优化问题，都必须限制在$a_0=-1$内。<br>另一方面，如果均方预测误差被约束为一致的，同时预测误差方程被包括在normal方程的顶部，增广组方程是由<br><img src="https://upload.wikimedia.org/math/8/c/c/8cc8ebbe7eee188032176043a514b23c.png" alt=""><br>得到，其中索引i从0到$p$，同时 $R$ 是一个 $(p + 1) × (p + 1)$ 矩阵。</p>
<p>线性预测参数的规范是一个很广泛的主题,而且大量的方法已经被提出。实际上，自相关方法是最常见的，例如在语音编码GSM标准中使用。</p>
<p>矩阵方程 $Ra = r$在计算量上是一个相对大的过程。矩阵求逆的高斯算法可能是最古老的方法，但这种方法并不能有效地使用R和r的对称性。一个更快的算法是Norman Levinson在1947年提出的Levinson recursion算法，利用递归来解决这个问题。特别是上面的自相关方程，可以更有效地被Durbin算法求解。<br>之后，Delsarte等0提出了一种对于这个算法的改进，称为split Levinson recursion 这个算法需要大约一半乘法和除法。它使用参数向量的一个特殊的对称属性在后来的递归上。也就是说，对于包含$P$项的最优预测点的计算利用了包含$P-1$项的最优预测点的相似计算值。<br>识别模型参数的另一种方式是迭代地计算出使用了卡尔曼滤波器和获得的期望最大化算法中的最大似然估计值的状态估计值。</p>
]]></content>
    <summary type="html">
    <![CDATA[第一次尝试翻译，来自维基百科]]>
    
    </summary>
    
      <category term="翻译" scheme="http://prozhuchen.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://prozhuchen.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[制作一个python egg 并发布到PyPI]]></title>
    <link href="http://prozhuchen.com/2015/11/02/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AApython%20egg%20%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0PyPI/"/>
    <id>http://prozhuchen.com/2015/11/02/制作一个python egg 并发布到PyPI/</id>
    <published>2015-11-02T02:32:19.000Z</published>
    <updated>2016-12-30T13:03:29.125Z</updated>
    <content type="html"><![CDATA[<p>最近写了一个可以在终端上输出ASCII表的Python公共库<a href="https://pypi.python.org/pypi?:action=display&amp;name=PrintTable&amp;version=1.0" target="_blank" rel="external">PrintTable</a>，GitHub地址<a href="https://github.com/prozhuchen/PrintTable" target="_blank" rel="external">github PrintTable</a>。<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/python%20egg%20%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0PyPI.jpg" alt=""></p>
<p>最后将脚本打包并且发布到PyPI的过程也是挺长的，第一次学习记录一下。</p>
<h1 id="1-_Python脚本_-&gt;_包">1. Python脚本 -&gt; 包</h1><p>首先我们先构建出自己包的架构。这里拿PrintTable这个项目的文件结构举例。</p>
<ul>
<li><a href="http://python-packaging-user-guide.readthedocs.org/en/latest/" target="_blank" rel="external">Python Packaging User Guide</a>这是Python打包的官方英文文档。 </li>
<li><a href="https://github.com/pypa/sampleproject" target="_blank" rel="external">PyPA sample project</a>这是一个官方示例库结构。</li>
</ul>
<pre><code>├── LICENSE
├── MANIFEST<span class="class">.in</span>
├── printtable
│   ├── __init__<span class="class">.py</span>
│   ├── printtable<span class="class">.py</span>
├── README<span class="class">.md</span>
├── setup<span class="class">.cfg</span>
├── setup.py
</code></pre><p>LICENSE：版权信息文件<br>MANIFEST.in：打包时不会被自动包含进去的附加文件清单<br>printtable：Python程序,我们要注意这个文件夹里必须有<code>__init__.py</code>这个文件。即使里面是空的。这样做是为了防止某些目录有一个共同的名字。<br>README.md：项目说明文件<br>setup.py：安装程序文件<br>setup.cfg：包含setup.py额外配置信息的文件</p>
<p>其中<code>setup.py</code>是我们主要需要配置的文件。</p>
<pre><code><span class="keyword">from</span> setuptools import setup, find_packages

setup(
    name = <span class="comment">'printtable',</span>
    version = <span class="comment">'1.0',</span>
    keywords = (<span class="comment">'print table'),</span>
    description = <span class="comment">'a library for drawing the table in the terminal',</span>
    license = <span class="comment">'MIT License',</span>
    url = <span class="comment">'https://github.com/prozhuchen/PrintTable',</span>
    author = <span class="comment">'prozhuchen',</span>
    author_email = <span class="comment">'prozhuchen@gmail.com',</span>
    packages = find_packages(),
    include_package_data = <span class="literal">True</span>,
    platforms = <span class="comment">'any',</span>
    install_requires = [],
)
</code></pre><p>上面这些配置信息一般已经够我们用了，如果需要更多的话，<a href="http://python-packaging-user-guide.readthedocs.org/en/latest/distributing/?highlight=manifest#setup-args" target="_blank" rel="external">setup.py配置信息</a>这是官方文档中setup.py的详细配置信息介绍。</p>
<p><code>MANIFEST.in</code>文件包含了一些打包时不会被自动包含进去的附加文件。其中最广泛包含进去的是<code>README.md</code>，因为这个项目说明文件打包时不会被自动包含进去。</p>
<pre><code><span class="preprocessor"><span class="keyword">include</span> README.md</span>
</code></pre><h1 id="2-_打包">2. 打包</h1><p>通过执行下列语句来进行打包：</p>
<pre><code>python setup<span class="class">.py</span> xxx
</code></pre><p>其中<code>xxx</code>可以是下列几种方式中其中一个：</p>
<pre><code>sdist             <span class="built_in">create</span> <span class="operator">a</span> source distribution (tarball, zip <span class="built_in">file</span>, etc.)
bdist             <span class="built_in">create</span> <span class="operator">a</span> built (binary) distribution
bdist_dumb        <span class="built_in">create</span> <span class="operator">a</span> <span class="string">"dumb"</span> built distribution
bdist_rpm         <span class="built_in">create</span> <span class="operator">an</span> RPM distribution
bdist_wininst     <span class="built_in">create</span> <span class="operator">an</span> executable installer <span class="keyword">for</span> MS Windows
bdist_egg         <span class="built_in">create</span> <span class="operator">an</span> <span class="string">"egg"</span> distribution
</code></pre><p>举个例子：</p>
<pre><code><span class="title">python</span> setup.py sdist　<span class="comment">#生成的文件支持 pip</span>
</code></pre><p>此时在根目录出现了<code>dist</code>文件夹，里面有<code>name-version.tar.gz</code>这个文件，这就是我们要发布到PyPI的压缩包了。</p>
<h1 id="3-_发布到PyPI">3. 发布到PyPI</h1><p>首先我们需要在PyPI上注册一个帐号，你可以选择<a href="https://pypi.python.org/pypi?:action=register_form" target="_blank" rel="external">PyPI注册页面</a>和命令行注册两种方式：</p>
<pre><code>$ python setup.py register -r pypi

running register
running egg_info
writing printtable.egg-info/PKG-INFO
writing top-level names to printtable.egg-info/top_level.txt
writing dependency_links to printtable.egg-info/dependency_links.txt
reading manifest file 'printtable.egg-info/SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'printtable.egg-info/SOURCES.txt'
running <span class="operator"><span class="keyword">check</span>
We need <span class="keyword">to</span> know who you <span class="keyword">are</span>, so please <span class="keyword">choose</span> either:
 <span class="number">1.</span> <span class="keyword">use</span> your existing login,
 <span class="number">2.</span> <span class="keyword">register</span> <span class="keyword">as</span> a <span class="keyword">new</span> <span class="keyword">user</span>,
 <span class="number">3.</span> have the <span class="keyword">server</span> generate a <span class="keyword">new</span> <span class="keyword">password</span> <span class="keyword">for</span> you (<span class="keyword">and</span> email it <span class="keyword">to</span> you), <span class="keyword">or</span>
 <span class="number">4.</span> quit
Your selection [<span class="keyword">default</span> <span class="number">1</span>]: 
<span class="number">1</span>
Username: prozhuchen
<span class="keyword">Password</span>: 
Registering prinble <span class="keyword">to</span> https://pypi.python.org/pypi
<span class="keyword">Server</span> response (<span class="number">200</span>): OK
<span class="keyword">I</span> can <span class="keyword">store</span> your PyPI login so future submissions will be faster.
(the login will be <span class="keyword">stored</span> <span class="keyword">in</span> /home/zc/.pypirc)
<span class="keyword">Save</span> your login (y/<span class="keyword">N</span>)?y</span>
</code></pre><p>当你注册完毕后，会在用户根目录下创建文件~/.pypirc，这样以后就不需要输入帐号密码了。</p>
<p>然后我们需要向PyPI上发布自己的源代码包。</p>
<pre><code><span class="variable">$python</span> setup<span class="class">.py</span> sdist upload 
...
Creating tar archive
removing <span class="string">'printtable-1.0'</span> (and everything under it)
running upload
Submitting dist/printtable-<span class="number">1.0</span><span class="class">.tar</span><span class="class">.gz</span> to https:<span class="comment">//pypi.python.org/pypi</span>
Server response (<span class="number">200</span>): OK
</code></pre><p>此时在网页上就可以看到自己的源代码包啦。<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/python%20egg%20%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0PyPI1.png" alt=""><br>现在我们使用<code>pip install packagename</code>,就可以使用我们自己写的Python库了。</p>
<p>每次我们想更新我们自己的库时，只需要更新代码文件夹内的代码和<code>setup.py</code>里的<code>version</code>即可。</p>
<h1 id="4-_注意">4. 注意</h1><p>每次上传时，我们的名字或者版本号两者有一个必须和以前的不一样，也就是打包生成的<code>name-version.tar.gz</code>名字和以前上传的压缩包不一样才行。覆盖是行不通的哦。</p>
]]></content>
    <summary type="html">
    <![CDATA[第一次学习脚本打包并且发布到PyPI,记录一下.]]>
    
    </summary>
    
      <category term="Python" scheme="http://prozhuchen.com/tags/Python/"/>
    
      <category term="Python" scheme="http://prozhuchen.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[shell错误  let:not found]]></title>
    <link href="http://prozhuchen.com/2015/10/19/shell%E9%94%99%E8%AF%AFlet-not-found/"/>
    <id>http://prozhuchen.com/2015/10/19/shell错误let-not-found/</id>
    <published>2015-10-19T04:08:24.000Z</published>
    <updated>2015-10-19T04:25:18.653Z</updated>
    <content type="html"><![CDATA[<p>今天遇到个错误:</p>
<pre><code>zc@zc-HP-<span class="number">242</span>-G1-Notebook-PC:~$ ./<span class="number">1</span><span class="class">.sh</span>
<span class="number">1</span><span class="class">.sh</span>: <span class="number">7</span>: <span class="number">1</span><span class="class">.sh</span>: let: not found
</code></pre><p>查了一下，发现是因为/bin/sh默认的软连接是dash，不是bash,我们可以通过下面的命令在/bin目录下看见这个:</p>
<pre><code>zc@zc-HP-<span class="number">242</span>-G1-Notebook-PC:/bin$ ll sh
lrwxrwxrwx <span class="number">1</span> root root <span class="number">4</span> Aug <span class="number">23</span>  <span class="number">2014</span> sh -&gt; dash*
</code></pre><p>我们直接<code>bash 1.sh</code>就可以了。<br>当然想永远解决的我们有两种方法解决：</p>
<ol>
<li>我们可以通过<code>chsh</code>命令进行改变，<code>chsh</code>可以改变目前用户的shell类型。</li>
</ol>
<pre><code>zc<span class="variable">@zc</span>-<span class="constant">HP</span>-<span class="number">242</span>-<span class="constant">G1</span>-<span class="constant">Notebook</span>-<span class="constant">PC</span><span class="symbol">:/bin</span><span class="variable">$ </span>chsh
密码： 
正在更改 zc 的 shell
请输入新值，或直接敲回车键以使用默认值
    登录 <span class="constant">Shell</span> [<span class="regexp">/bin/bash</span>]<span class="symbol">:</span> 
</code></pre><p>我这里直接是我想要的，所以敲回车即可。如果不是/bin/bash，你就写这个路径就行啦。但是这个命令有一个缺点：</p>
<pre><code>zc@zc-HP-<span class="number">242</span>-G1-Notebook-PC:~$ ./<span class="number">1.</span>sh
count = <span class="number">2</span>
zc@zc-HP-<span class="number">242</span>-G1-Notebook-PC:~$ sh <span class="number">1.</span>sh
<span class="number">1.</span>sh: <span class="number">7</span>: <span class="number">1.</span>sh: let: not found
count = <span class="number">1</span>
</code></pre><p>大家不用关心这个输出是什么…但是我们看到了用.是成功了,用sh还是<code>let: not found</code>。</p>
<ol>
<li>第二个方法是改变/bin/sh的连接。输入命令<code>sudo ln -sf /bin/bash /bin/sh</code>，然后输入<code>ll /bin/sh</code>，可以看到下面的情况。</li>
</ol>
<pre><code>zc<span class="annotation">@zc</span>-HP-<span class="number">242</span>-G1-Notebook-<span class="string">PC:</span>~$ sudo ln -sf <span class="regexp">/bin/</span>bash <span class="regexp">/bin/</span>sh
zc<span class="annotation">@zc</span>-HP-<span class="number">242</span>-G1-Notebook-<span class="string">PC:</span>~$ ll <span class="regexp">/bin/</span>sh
lrwxrwxrwx <span class="number">1</span> root root <span class="number">9</span> Oct <span class="number">19</span> <span class="number">12</span>:<span class="number">05</span> <span class="regexp">/bin/</span>sh -&gt; <span class="regexp">/bin/</span>bash*
</code></pre><p>这次就算是解决了。</p>
<pre><code>zc@zc-HP-<span class="number">242</span>-G1-Notebook-PC:~$ sh <span class="number">1.</span>sh
count = <span class="number">2</span>
zc@zc-HP-<span class="number">242</span>-G1-Notebook-PC:~$ ./<span class="number">1.</span>sh
count = <span class="number">2</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[shell错误let:not found 及解决方法]]>
    
    </summary>
    
      <category term="Shell" scheme="http://prozhuchen.com/tags/Shell/"/>
    
      <category term="Shell" scheme="http://prozhuchen.com/categories/Shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客之改字体]]></title>
    <link href="http://prozhuchen.com/2015/10/05/Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%94%B9%E5%AD%97%E4%BD%93/"/>
    <id>http://prozhuchen.com/2015/10/05/Hexo博客之改字体/</id>
    <published>2015-10-05T06:14:47.000Z</published>
    <updated>2015-10-05T06:15:51.815Z</updated>
    <content type="html"><![CDATA[<p>觉得自己的博客字体不好看，在网上找了半天也没有相应的资料，所以这一次我们来看看杂么改掉自己Hexo博客的字体。</p>
<p>首先找到自己字体和字体大小的文件。<br>字体在<code>/themes/hexo-theme-next/source/css/_variables</code>下的<code>custom.styl</code>（这个是NexT主题的目录，其他主题请按图索骥）。<br>字体大小在<code>/themes/hexo-theme-next/source/css/_variables</code>下的<code>base.styl</code>。</p>
<p>然后我们来看怎么改动。<br><code>custom.styl</code>文件：</p>
<pre><code><span class="variable">$font-family-headings</span> = Georgia, sans // 标题，修改成你期望的字体族
<span class="variable">$font-family-base</span> = <span class="string">"Microsoft YaHei"</span>, Verdana, sans-serif // 修改成你期望的字体族
</code></pre><p>我们可以看出来第一个字体变量是题目的字体，第二个是其余部分的字体。<br>因为我们是中文博客，所以肯定希望能改成一些比较漂亮的中文字体，但是显而易见，你改成<code>宋体</code>是不合理的，因为第一会出现乱码情况，第二Hexo也不接受中文名字的字体。所以我们需要使用中文字体的英文名称。下面是中文字体对应的英文名称。</p>
<pre><code>新细明体：PMingLiU 
细明体：MingLiU 
标楷体：DFKai-SB 
黑体：SimHei 
宋体：SimSun 
新宋体：NSimSun 
仿宋：FangSong 
楷体：KaiTi 
仿宋_GB2312：FangSong_GB2312 
楷体_GB2312：KaiTi_GB2312 
微软正黑体：Microsoft JhengHei 
微软雅黑体：Microsoft YaHei 

装Office会多出来的一些字体： 
隶书：LiSu 
幼圆：YouYuan 
华文细黑：STXihei 
华文楷体：STKaiti 
华文宋体：STSong 
华文中宋：STZhongsong 
华文仿宋：STFangsong 
方正舒体：FZShuTi 
方正姚体：FZYaoti 
华文彩云：STCaiyun 
华文琥珀：STHupo 
华文隶书：STLiti 
华文行楷：STXingkai 
华文新魏：STXinwei 

苹果电脑中的字体： 
华文细黑：STHeiti Light [STXihei] 
华文黑体：STHeiti 
华文楷体：STKaiti 
华文宋体：STSong 
华文仿宋：STFangsong 
丽黑 <span class="keyword">Pro</span>：LiHei <span class="keyword">Pro</span> Medium 
丽宋 <span class="keyword">Pro</span>：LiSong <span class="keyword">Pro</span> Light 
标楷体：BiauKai 
苹果丽中黑：Apple LiGothic Medium 
苹果丽细宋：Apple LiSung Light 
</code></pre><p>我们只要将自己喜欢字体的英文名加到这两个变量的第一个前面就可以了，有多个字体是为了预防在某些场合前面的字体出现异常，后面的字体可以替代一下。下面是我的定义。</p>
<pre><code><span class="variable">$font-family-headings</span> = KaiTi,<span class="string">"Microsoft YaHei"</span>,Georgia, sans // 标题，修改成你期望的字体族
<span class="variable">$font-family-base</span> = SimHei, Verdana, sans-serif // 修改成你期望的字体族
</code></pre><p>至于字体大小，我们在前面提到的<code>base.styl</code>里面61行左右会看见如下定义<br>：</p>
<pre><code>// Font size
<span class="variable">$font-size-base</span>           = <span class="number">18</span>px
<span class="variable">$font-size-small</span>          = <span class="variable">$font-size-base</span> - <span class="number">2</span>px
<span class="variable">$font-size-smaller</span>        = <span class="variable">$font-size-base</span> - <span class="number">4</span>px
<span class="variable">$font-size-large</span>          = <span class="variable">$font-size-base</span> + <span class="number">4</span>px

// Headings font size
<span class="variable">$font-size-headings-base</span>  = <span class="number">28</span>px
<span class="variable">$font-size-headings-step</span>  = <span class="number">2</span>px
</code></pre><p>同理，第一个部分<code>$font-size-base</code>是除了标题外的其余部分大小，第二个部分<code>$font-size-headings-base</code>是标题大小，你改动成你希望的大小就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[这一次我们来看看怎么改掉自己Hexo博客的字体。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第九又四分之三站：剩下的小东西]]></title>
    <link href="http://prozhuchen.com/2015/10/04/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B9%9D%E5%8F%88%E5%9B%9B%E5%88%86%E4%B9%8B%E4%B8%89%E7%AB%99/"/>
    <id>http://prozhuchen.com/2015/10/04/Hexo博客第九又四分之三站/</id>
    <published>2015-10-04T06:55:10.000Z</published>
    <updated>2016-12-30T13:02:18.671Z</updated>
    <content type="html"><![CDATA[<p>最后看了看还是有点小东西没说，但是前面都已经写完结尾了啊啊啊，所以在此补了个九又四分之三站(不知道深意的请百度哈利波特站台….)，有缘分的小伙伴进来看一看有木有你能用上的。</p>
<h1 id="1-_Hexo_+_README">1. Hexo + README</h1><p>每次进入GitHub的gh-pages分支都提醒写README，烦死了，我们在根目录下的<code>source</code>下面新建一个README文件，写上对自己博客的描述啥的，再次生成部署就会发现README已经传上去了。</p>
<h1 id="2-_Hexo_+_404">2. Hexo + 404</h1><p>GitHub本身给我们配置了404页面，如果是做自己的404页面，你可以像上面一样，在<code>source</code>里面加上404.html，但是注意，自定义的404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。例如，如果一开始你的域名是XXX.github.io,你就可以在XXX.github.io/404.html看到你的404页面，但是如果你的域名是XXX.github.io/blog，那么你就无法看到自己的404了。<br>现如今，很多人都把自己的404页面当做公益项目的传播，为社会做点自己的贡献，例如这样子：<a href="http://prozhuchen.github.io/404.html" target="_blank" rel="external">404页面</a>。下面是几个公益404的地址。</p>
<ul>
<li><a href="http://www.qq.com/404/" target="_blank" rel="external">腾讯公益404</a></li>
<li><a href="http://yibo.iyiyun.com/Index/web404" target="_blank" rel="external">404公益_益云(公益互联网)社会创新中心</a></li>
<li><a href="http://404page.missingkids.org.tw/" target="_blank" rel="external">失蹤兒童少年資料管理中心404</a></li>
</ul>
<h1 id="3-_hexo_+_图床">3. hexo + 图床</h1><p>我们的博客部署在GitHub上虽然有很多好处，但是有一个问题，他的个人空间只有100M！如果光是普通文件也就差不多够了，但是有图片可怎么办呐。所以我们可以把图片放在图床上，然后用外链地址来引用图片，问题解决。<br>我用的图床是七牛，他的体验用户是1G，标准用户是10G，而且免费的，应该够绝大多数个人博客的使用了。这里是七牛的地址 <a href="https://portal.qiniu.com/signup?code=3lpoc69h8k502" target="_blank" rel="external">七牛</a>。这里说一下七牛的简单使用。<br>我们首先注册（想成为标准用户得通过个人验证），完成后新建一个空间，名字任意。<br>此时我们进入空间，选择内容管理，然后上传图片，点击该图片后右边会出现图片的缩略图和外链地址，我们复制该外链地址，即图片的访问地址到自己的文章里，就可以看到图片啦。</p>
<h1 id="4-_hexo_+_社交连接，友情链接">4. hexo + 社交连接，友情链接</h1><p>我们在站点配置文件中，加入如下的语句，随便加，别客气！</p>
<pre><code><span class="comment"># 社交链接，将在侧栏中显示</span>
<span class="symbol">social:</span>
  知乎<span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/www.zhihu.com/people</span><span class="regexp">/zhu-chen-71-40
  GitHub: https:/</span><span class="regexp">/github.com/prozhuchen</span>
  <span class="comment"># Twitter: your-twitter-url</span>
  <span class="comment"># Weibo: your-weibo-url</span>
  <span class="comment"># DouBan: your-douban-url</span>
  <span class="comment"># ZhiHu: your-zhihu-url</span>
  <span class="comment"># 等等</span>

<span class="comment">#友情链接，将在侧栏中显示</span>
<span class="symbol">links_title:</span> 友情链接
<span class="symbol">links:</span>
  我的<span class="constant">CSDN</span>博客<span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/blog.csdn.net/u</span>010006643
</code></pre><h1 id="5-_结束啦">5. 结束啦</h1><p>首先感谢网上大神们的博客，很牛，也解决了自己的很多问题，可惜好多博文没有记住…..如果您发现了我引用了你的博客，而且需要我进行说明，我将会尽快说明，在此感谢大神们博客的帮助。<br>经过这几天的整理，总算把自己挖空了。请小伙伴们如果发现错误在下面留言告诉我，我将不胜感激。有疑问的话我也会尽力给大家解决。希望大家能愉快的交流与学习&lt;(￣ˇ￣)/。</p>
]]></content>
    <summary type="html">
    <![CDATA[README + 404页面 + 图床 + 社交与友情链接]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第五站：文章配置+Markdown语法]]></title>
    <link href="http://prozhuchen.com/2015/10/03/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%AB%99/"/>
    <id>http://prozhuchen.com/2015/10/03/Hexo博客第五站/</id>
    <published>2015-10-03T07:53:11.000Z</published>
    <updated>2016-12-30T13:01:25.852Z</updated>
    <content type="html"><![CDATA[<p>现在我们可以尽情写自己想写的东西了。但是首先我们得学会在哪写和怎么写。</p>
<h1 id="1-_在哪写(Hexo_文章配置)">1. 在哪写(Hexo 文章配置)</h1><h2 id="1-1_从别处迁移">1.1 从别处迁移</h2><p>如果我们之前在别的网站已经有了自己,./的博客，那当然不能直接扔掉啦，Hexo可以从RSS/Jekyll/Octopress/Wordpress迁移之前的博客（传送门 <a href="http://zespia.tw/hexo/docs/migration.html" target="_blank" rel="external">从别处迁移到Hexo</a>）。</p>
<h2 id="1-2_自己写">1.2 自己写</h2><p>首先我们在Git Bash中输入：</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"article name"</span>
</code></pre><p>然后我们在博客根目录<code>/source/_posts</code>下会看见新产生的<code>article name.md</code>。<br>如果我们想改变这个名字的格式，就可以在站点配置文件的31行左右改变<code>new_post_name</code>，下面将名字格式改成了类似这样的<code>2015-09-29-name.md</code>：</p>
<pre><code><span class="comment"># Writing</span>
<span class="symbol">new_post_name:</span> <span class="symbol">:year-</span><span class="symbol">:month-</span><span class="symbol">:day-</span><span class="symbol">:title</span>.md <span class="comment"># File name of new posts</span>
<span class="symbol">default_layout:</span> post
<span class="symbol">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span>
<span class="symbol">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span>
<span class="symbol">filename_case:</span> <span class="number">0</span>
<span class="symbol">render_drafts:</span> <span class="literal">false</span>
</code></pre><p>然后重新生成一篇文章，可以看到产生的是<code>2015-09-29-article name.md</code>吧。</p>
<p>此时我们进入这篇文章，可以看见：</p>
<pre><code>title: q                  <span class="comment">//文章的名字</span>
date: <span class="number">2015</span>-<span class="number">10</span>-<span class="number">03</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">11</span> <span class="comment">//你生成这篇文章的时间</span>
tags:                     <span class="comment">//文章的标签</span>
....
</code></pre><p>类似这样的开头属性还有：</p>
<pre><code>updated     修改日期        文件的修改日期    
comments    是否开启评论    <span class="function"><span class="title">true</span><span class="params">(默认)</span></span>   
tags        文章标签          
categories  文章分类    
permalink   url中的名字    文件名
description 文章摘要
</code></pre><p>举两个例子：</p>
<pre><code><span class="comment">//这个文章不允许别人评论，默认评论是开启的</span>
title: Hexo博客第二站：部署到GitHub
date: <span class="number">2015</span>-<span class="number">09</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">29</span>:<span class="number">48</span>
comments: <span class="literal">false</span>

<span class="comment">//这个文章有两个标签，属于两个类别</span>
title: Hexo博客第二站：部署到GitHub
date: <span class="number">2015</span>-<span class="number">09</span>-<span class="number">30</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">50</span>
tags:
- Hexo
- GitHub
categories:
- Hexo
- GitHub
</code></pre><p>接下来我们就可以在下面写自己的文章啦，但是文章要符合Markdown语法，MarkDown语法是啥子？我们要咋写啊？</p>
<h1 id="2-_怎么写（Markdown）">2. 怎么写（Markdown）</h1><blockquote>
<p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。</p>
</blockquote>
<p>网上有很多的Markdown软件，我用的是<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">作业部落</a>，感觉这个软件做的很不错。其他的也有一些人是用sublime+插件（传送门 <a href="http://www.jianshu.com/p/378338f10263" target="_blank" rel="external">sublime text 2 下的Markdown写作</a>），大家可以自己选择自己想要的。</p>
<p>至于Markdown语法，一开始准备自己写，但是后来发现有好多内容网上已经有了，再写出来会很重复。所以基本语法我就不提了。在这里说一些我在用Markdown时的心得。</p>
<ol>
<li>NexT主题有一个配置选项<code>toc_list_number: true</code>，这个选项使我们的目录会自动配上顺序标号，所以我们在自己写的时候可以不用带上了，如果不习惯的话，把这个配置注释掉即可。</li>
<li><p>在用Markdown写命令的时候，我们将命令缩进四个空格，就会出现下面的情况。</p>
<pre><code>此处是你的命令
</code></pre></li>
</ol>
<p>绝大部分时候，一个Tab就是四个空格，当然你也可以设置，例如用sublime写作时，你就可以设定一个Tab等于多少空格。</p>
<ol>
<li><p>在用Markdown写代码的时候，我们只要用三个点将代码包起来就可以，Markdown会自动进行代码高亮和分辨语言。就像这样：</p>
<pre><code><span class="comment"><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></span>
</code></pre></li>
</ol>
<p>Markdown变得越来越流行，他的兼容性和可读性可以胜任各个场合，而且如果伴随着一些专业编辑器，我们的写作速度大大加快了。</p>
<p>从现在开始，大家可以开始自己的博客创作之路了！</p>
]]></content>
    <summary type="html">
    <![CDATA[我们来学习在哪写文章和怎么写文章。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第四站：搜索引擎+小插件+配置结构分析]]></title>
    <link href="http://prozhuchen.com/2015/10/03/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E5%9B%9B%E7%AB%99/"/>
    <id>http://prozhuchen.com/2015/10/03/Hexo博客第四站/</id>
    <published>2015-10-03T06:46:38.000Z</published>
    <updated>2016-12-30T13:00:19.103Z</updated>
    <content type="html"><![CDATA[<p>接着我们上次来继续加加加东西。</p>
<p>此时说明一下，大家可能看到我的博客和你们NexT主题显示的不一样，这是因为NexT主题包含两种主题，我们在主题配置文件中的40行左右可以看见：</p>
<pre><code><span class="preprocessor"># Schemes</span>
<span class="label">scheme:</span> Mist  <span class="preprocessor">#这一列默认是注释掉的，如果把这个取消注释，就会变成我的博客的主题样式。</span>
</code></pre><h1 id="1-_搜索引擎">1. 搜索引擎</h1><p>NexT主题支持了两种搜索引擎：Swiftype和微搜索。一个是国外的，一个是国内的。微搜索做的还不错，但是我搜索的时候总觉得有些延迟；至于Swiftype，真的真的很好用，良心厂家强力推荐。<br>有人说注册以后是30天试用，这个没关系，网站给的是30天高级账户的使用（那种有可以建立多个搜索引擎、多账户共同管理、一个引擎index多个域名的功能的账户），30天到期后你可选择花钱继续用这个高级账户（土豪自便），或者选择降级成为免费的账户类型，也就是我现在用的那种，所以，不用担心。<br>Swiftype网站的配置，网上其他好多的都是说的老版Swiftype的配置，比较落后了，这里提供给大家一位博主的博客，说的很详细。传送门　<a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html" target="_blank" rel="external">利用swiftype为hexo添加站内搜索</a>。<br>至于主题上的配置，我们只要在你的站点配置文件（不是主题配置文件）上加上这样一句话即可。</p>
<pre><code># <span class="keyword">Swiftype </span>Search Key
<span class="keyword">swiftype_key: </span>你的<span class="keyword">swiftype_key</span>
</code></pre><p>swiftype_key：在你Swiftype网站配置完后，我们看到了一个JS文件。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E5%9B%9B%E7%AB%991.jpg" alt=""><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">w,d,t,u,n,s,e</span>)</span>&#123;w[<span class="string">'SwiftypeObject'</span>]=n;w[n]=w[n]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(<span class="built_in">arguments</span>);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[<span class="number">0</span>];s.async=<span class="number">1</span>;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">'script'</span>,<span class="string">'//s.swiftypecdn.com/install/v2/st.js'</span>,<span class="string">'_st'</span>);</span><br><span class="line"></span><br><span class="line">  _st(<span class="string">'install'</span>,<span class="string">'yx9-swpbwqxuFPaTyCzz'</span>,<span class="string">'2.0.0'</span>);<span class="comment">//yx9-swpbwqxuFPaTyCzz 就是 swiftype_key，不同的人不一样。</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="2-_安装插件RSS与_sitemap">2. 安装插件RSS与 sitemap</h1><p>Sitemap:</p>
<blockquote>
<p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
</blockquote>
<p>这个Sitemap还是很有用的，例如本来你在google上搜索自己的新帖子是很难搜索到的，但是你向google提交sitemap后，自己的帖子变得容易搜索到多了。</p>
<p>RSS:</p>
<blockquote>
<p>RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网站内容的格式。你可以认为是一种定制个性化推送信息的服务。它能解决你漫无目的浏览网页的问题。它不会过时，信息越是过剩，它的意义也越加彰显。</p>
</blockquote>
<p>首先我们安装前人写好的插件。</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span>
</code></pre><p>然后在站点配置文件上输入下面的语句：</p>
<pre><code><span class="attribute">plugins</span>:
- hexo-generator-feed
- hexo-generator-sitemap

<span class="attribute">sitemap</span>:
  <span class="attribute">path</span>: sitemap.xml

<span class="attribute">feed</span>:
  <span class="attribute">path</span>: atom.xml
</code></pre><p>上面的path说明了博客生成后的位置在根目录下，也是你访问网址是你的根地址+path。<br>此时你访问<code>http://127.0.0.1:4000/atom.xml</code>就能看到RSS的内容啦，sitemap访问同理。 如果想向google提交自己的sitemap，请看这个博客。传送门 <a href="http://fionat.github.io/blog/2013/10/23/sitemap/" target="_blank" rel="external">如何向google提交sitemap（详细）</a> ，过一天左右，你就能在google搜索到自己的新博客啦。</p>
<hr>
<h1 id="3-_加入”关于我”_和DIY界面">3. 加入”关于我” 和DIY界面</h1><p>一开始我们的主页里面只有主页，归档和标签三个栏目。我们可以加一些自己DIY的界面。<br>我们在Git Bash中输入这样一句命令。</p>
<pre><code>hexo <span class="keyword">new</span> page <span class="string">"about"</span>
</code></pre><p>这时我们进入博客根目录下的<code>source</code>可以发现多了一个<code>about</code>文件夹，里面有一个<code>index.md</code>,此时我们进入主题配置文件（就是在主题目录下的_config.yml），对第五行进行更改。</p>
<pre><code><span class="attribute">menu</span>:
  <span class="attribute">home</span>: /
  #<span class="attribute">categories</span>: /categories
  <span class="attribute">about</span>: /about
  <span class="attribute">archives</span>: /archives
  <span class="attribute">tags</span>: /tags
  #<span class="attribute">commonweal</span>: /<span class="number">404</span>.html
</code></pre><p>此时再重新生成可以看见我们的页面多了一个关于的栏目啦。<br>如果我们想加入一些新的栏目，例如我上面出现的留言呢，可以再次这么敲命令：</p>
<pre><code>hexo <span class="keyword">new</span> page <span class="string">"guestbook"</span>
</code></pre><p>然后在主题配置文件进行更改，加一句 <code>guestbook: guestbook</code>。</p>
<pre><code><span class="attribute">menu</span>:
  <span class="attribute">home</span>: /
  #<span class="attribute">categories</span>: /categories
  <span class="attribute">about</span>: /about
  <span class="attribute">archives</span>: /archives
  <span class="attribute">tags</span>: /tags
  <span class="attribute">guestbook</span>: guestbook
  #<span class="attribute">commonweal</span>: /<span class="number">404</span>.html
</code></pre><p>此时我们重新生成发现页面上多出来的是guestbook，而不是我们想要的留言。这时候我们在<code>/themes/hexo-theme-next/languages/zh-Hans.yml</code>的目录下（这里默认你使用的是简体中文，若是其他语言更改相应的yml就行），在memu下加一句即可。</p>
<pre><code><span class="attribute">guestbook</span>: <span class="string">留言</span>
</code></pre><p>此时再重新生成可以看见我们的页面多了一个留言的栏目啦。如果你想要其他的DIY栏目，勇敢的去做吧！</p>
<hr>
<h1 id="4-_主题配置文件结构分析">4. 主题配置文件结构分析</h1><p>主题配置文件就是在主题目录下的_config.yml，这里对我们常用的配置进行一下讲解。</p>
<pre><code><span class="preprocessor"># when running hexo in a subdirectory (e.g. domain.tld/blog), remove leading slashes ( "/archives" -&gt; "archives" )</span>
menu:                         # 这是你主页最上面出现的栏目
  home: /blog/
  archives: /blog/archives
  categories: /blog/categories
  tags: /blog/tags
  guestbook: /blog/guestbook
  # about: /blog/about
  # commonweal: /blog/<span class="number">404.</span>html

<span class="preprocessor"># Place your favicon.ico to /source directory.</span>
favicon: images/favicon.ico   #这是我们网站的图标

<span class="preprocessor"># Set default keywords (Use a comma to separate)</span>
keywords: <span class="string">"Hexo,next"</span>        

<span class="preprocessor"># Set rss to false to disable feed link.</span>
<span class="preprocessor"># Leave rss as empty to use site's feed link.</span>
<span class="preprocessor"># Set rss to specific value if you have burned your feed already.</span>
rss: /blog/atom.xml           #这是我们RSS的地址

<span class="preprocessor"># Icon fonts</span>
<span class="preprocessor"># Place your font into next/source/fonts, specify directory-name and font-name here</span>
<span class="preprocessor"># Avialable: default | linecons | fifty-shades | feather</span>
<span class="preprocessor">#icon_font: default           #这是我们图标字体的样式</span>
<span class="preprocessor"># icon_font: fifty-shades</span>
icon_font: feather
<span class="preprocessor">#icon_font: linecons</span>

<span class="preprocessor"># Code Highlight theme</span>
<span class="preprocessor"># Available value: normal | night | night eighties | night blue | night bright</span>
<span class="preprocessor"># https://github.com/chriskempson/tomorrow-theme</span>
highlight_theme: night eighties    #这是我们代码高亮的样式，你可以自己改变来看看每一种样式。


<span class="preprocessor"># MathJax Support</span>
mathjax: <span class="literal">true</span>          #显示数学公式的功能，默认是空，如果打开就设为<span class="literal">true</span>



<span class="preprocessor"># Schemes</span>
scheme: Mist    #NexT主题有两种主题，这里默认是注释掉的，取消注释的话就是我博客的样式。


<span class="preprocessor"># Sidebar, available value:</span>
<span class="preprocessor">#  - post    expand on posts automatically. Default.</span>
<span class="preprocessor">#  - always  expand for all pages automatically</span>
<span class="preprocessor">#  - hide    expand only when click on the sidebar toggle icon.</span>
sidebar: post     #这个是侧边栏的显示模式，默认是在阅读帖子的时候自动打开。
<span class="preprocessor">#sidebar: always</span>
<span class="preprocessor">#sidebar: hide</span>


<span class="preprocessor"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span>
scroll_to_more: <span class="literal">true</span>    #启动摘取一部分作为摘要，剩余的在阅读全文里。


<span class="preprocessor"># Automatically add list number to toc.</span>
toc_list_number: <span class="literal">true</span>   #自动在目录里加入列表数字
</code></pre><p>到现在基本的东西我们都算是有啦，现在可以准备开始写博客了。</p>
]]></content>
    <summary type="html">
    <![CDATA[接着我们上次来继续加加加东西。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第三站：安装主题+第三方评论+网站统计]]></title>
    <link href="http://prozhuchen.com/2015/10/01/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E7%AB%99/"/>
    <id>http://prozhuchen.com/2015/10/01/Hexo博客第三站/</id>
    <published>2015-10-01T15:14:50.000Z</published>
    <updated>2016-12-30T12:59:03.748Z</updated>
    <content type="html"><![CDATA[<p>接着我们开始丰富我们的博客。<a id="more"></a></p>
<p>再次提示：</p>
<ol>
<li>下面输入的命令都在 Git Bash 中输入。</li>
<li>下文提到的目录地址都是面对NexT主题的，不过其他主题的索引也都大同小异。</li>
</ol>
<h1 id="1-_hexo博客结构">1. hexo博客结构</h1><p>在这里，我们先来看看hexo自动生成的博客的主要结构。</p>
<pre><code>├─scaffolds      <span class="comment">//每篇帖子模板所在地</span>
├─source         
│  └─_posts      <span class="comment">//这里放着我们写的帖子 里面初始化一篇hello-world.md</span>
└─themes         <span class="comment">//hexo博客主题所在地</span>
    └─landscape  <span class="comment">//初始化主题默认为landscape</span>
├─node_modules   <span class="comment">//hexo的驱动文件所在地</span>
├─_config<span class="class">.yml</span>    <span class="comment">//hexo博客配置文件</span>
</code></pre><p>这些都是我们有可能去改变的。看完了这个，接下来开始让我们的博客变得添砖加瓦吧。</p>
<h1 id="2-_添砖加瓦">2. 添砖加瓦</h1><h2 id="2-1_安装主题">2.1 安装主题</h2><p>一个好看的主题可以更加吸引读者，但是从头设计主题也太麻烦了吧~，所以Hexo有很多现成的主题。传送门 [ <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo主题</a> ]<br>我们利用语句下载下来我们需要的主题。例如我们下载<code>hexo-theme-next</code>这个主题。</p>
<pre><code><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/iissnan</span><span class="regexp">/hexo-theme-next.git themes/hexo</span>-theme-<span class="keyword">next</span>
</code></pre><p>然后进入上面提到的 themes 文件夹下，可以看见出现了hexo-theme-next文件夹。此时我们到博客根目录下的 _config.yml，修改博客所用的主题 (第66行) 。</p>
<pre><code><span class="preprocessor"># Extensions</span>
<span class="preprocessor">## Plugins: http://hexo.io/plugins/</span>
<span class="preprocessor">## Themes: http://hexo.io/themes/</span>
theme: hexo-theme-next
</code></pre><p>改完后，我们在 Git Bash 中输入</p>
<pre><code>hexo <span class="keyword">g</span>
hexo <span class="literal">s</span>
</code></pre><p>进入 [ <a href="http://127.0.0.1:4000/" target="_blank" rel="external">http://127.0.0.1:4000/</a> ] 查看我们的页面，是不是变得高大上多啦。这一章主要是完善博客所必须的一些内容。</p>
<h2 id="2-2_第三方评论">2.2 第三方评论</h2><p>博客怎么能没有让小伙伴说话的地方呢。因为Hexo博客是静态博客，所以评论系统我们得靠其他的插件了。NexT这个主题支持 Disqus 和多说两种第三方评论插件。我使用的是多说。Disqus的看这里有提到  <a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo在github上构建免费的Web应用</a>。</p>
<ol>
<li>进入<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>平台，点击 “ 我要安装 “ 。</li>
<li>配置好自己的站点，注意多说域名这一栏是我们接下来需要的东西。站点地址就是你Hexo博客上传的GitHub页面地址。</li>
<li>在你的站点配置文件 (不是主题配置文件) _config.yml加一行：<code>duoshuo_shortname: 你的多说域名</code> ( 多说域名: 你的多说二级域名去掉 .duoshuo.com 部分 )</li>
<li>再次生成上传 <code>hexo g</code>，<code>hexo d</code> （没有事先部署到GitHub上的看这里  <a href="http://prozhuchen.github.io/blog/2015/09/30/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%BA%8C%E7%AB%99/" target="_blank" rel="external">Hexo博客第二站：部署到GitHub上</a>）,点击文章hello-world，是不是看见最下方出现了评论系统啦。管理的话进入多说的后台管理就行了。</li>
<li>**有人可能觉得多说的标准css样式不怎么好看。你可以进入后台管理-设置-基本设置-自定义CSS里面编辑自己想要的。我用的是从网上借鉴来，自己改动了一些的。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ds-reset</span> <span class="class">.ds-avatar</span>,</span><br><span class="line"><span class="id">#ds-recent-visitors</span> <span class="class">.ds-avatar</span><span class="rules">&#123; </span><br><span class="line">  <span class="rule"><span class="attribute">filter</span>:<span class="value"> <span class="function">alpha</span>(opacity=<span class="number">0</span>)</span></span>;   <span class="comment">/*设置图片背景透明*/</span></span><br><span class="line">    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;  </span><br><span class="line">    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;  </span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#ds-reset</span> <span class="class">.ds-avatar</span> <span class="tag">img</span>,</span><br><span class="line"><span class="id">#ds-recent-visitors</span> <span class="class">.ds-avatar</span> <span class="tag">img</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">54px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">54px</span></span></span>;     <span class="comment">/*设置图像的长和宽，这里要根据自己的评论框情况更改*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">27px</span></span></span>;     <span class="comment">/*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-border-radius</span>:<span class="value"> <span class="number">27px</span></span></span>;     <span class="comment">/*圆角效果：兼容webkit浏览器*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-moz-border-radius</span>:<span class="value"> <span class="number">27px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="hexcolor">#3333</span>sf</span></span>;     <span class="comment">/*设置图像阴影效果*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-box-shadow</span>:<span class="value"> inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="hexcolor">#3333</span>sf</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value"> <span class="number">0.4s</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value"> -webkit-transform <span class="number">0.4s</span> ease-out</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transition</span>:<span class="value"> transform <span class="number">0.4s</span> ease-out</span></span>;     <span class="comment">/*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-moz-transition</span>:<span class="value"> -moz-transform <span class="number">0.4s</span> ease-out</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#ds-reset</span> <span class="class">.ds-avatar</span> <span class="rule"><span class="attribute">img</span>:<span class="value">hover,</span><br><span class="line"><span class="hexcolor">#d</span>s-recent-visitors .ds-avatar img:hover &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置鼠标悬浮在头像时的CSS样式*/</span>    box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">  <span class="tag">rgba</span>(255, 255, 255, <span class="class">.6</span>), <span class="tag">inset</span> 0 0 20<span class="tag">px</span> <span class="tag">rgba</span>(255, 255, 255, 1);</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-box-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">  <span class="tag">rgba</span>(255, 255, 255, <span class="class">.6</span>), <span class="tag">inset</span> 0 0 20<span class="tag">px</span> <span class="tag">rgba</span>(255, 255, 255, 1);</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateZ</span>(<span class="number">360deg</span>)</span></span>;     <span class="comment">/*图像旋转360度*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">rotateZ</span>(<span class="number">360deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-moz-transform</span>:<span class="value"> <span class="function">rotateZ</span>(<span class="number">360deg</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="id">#ds-recent-visitors</span> <span class="class">.ds-avatar</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*隐藏多说底部版权*/</span></span><br><span class="line"><span class="hexcolor">#d</span>s-thread <span class="hexcolor">#d</span>s-reset .ds-powered-by &#123;</span><br><span class="line">  display: none</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-3_博客分享">2.3 博客分享</h2><p>我们的博客写的好，会有人希望分享给其他人看。NexT主题有两个分享部件：多说分享和JiaThis。多说分享首先必须启用了多说才能使用。我们在站点配置文件下加上如下的语句，如果你想开启多说分享服务，把jiathis注释掉，取消duoshuo_share的注释就行啦。</p>
<pre><code><span class="preprocessor"># JiaThis 分享服务</span>
jiathis: <span class="literal">true</span>

<span class="preprocessor"># 多说热评文章服务</span>
duoshuo_hotartical: <span class="literal">true</span>

<span class="preprocessor"># # 多说 分享服务（必须启用多说）</span>
<span class="preprocessor"># duoshuo_share: true</span>
</code></pre><h2 id="2-4_网站统计">2.4 网站统计</h2><p>其实我觉得google，百度统计这些对于许多人用不太上，毕竟不能直接观察到自己的博客有多少人看了什么的。如果需要安装的看这里&gt;<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E6%B7%BB%E5%8A%A0-Google---%E7%99%BE%E5%BA%A6-%E7%BB%9F%E8%AE%A1" target="_blank" rel="external">添加 Google, 百度统计</a>。这里推荐一个小插件-<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="external">不蒜子</a>。这个小插件可以让你轻而易举的看见自己的博客火热程度，例如访问量和访问人数等。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E7%AB%991.jpg" alt=""></p>
<p>有一个好玩的小地方，你为了想看到每一篇文章的阅读量，你可以在<code>/themes/hexo-theme-next/layout/_macro/post.swig</code>里面的下面的位置加上如下代码，(这个热度是从一个博客上看到的，感觉很有趣哈):<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template_tag">&#123;% <span class="keyword">if</span> post.categories and post.categories.length %&#125;</span><span class="xml"></span><br><span class="line">         <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"post-category"</span> &gt;</span></span><br><span class="line">    </span><br><span class="line">         <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">       </span><span class="template_tag">&#123;% <span class="keyword">endif</span> %&#125;</span><span class="xml"></span><br><span class="line">       </span><br><span class="line">  <span class="comment">&lt;!-- 在下面的位置加上如下代码 --&gt;</span></span><br><span class="line">  </span><br><span class="line">       <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_container_page_pv"</span>&gt;</span></span><br><span class="line">       &amp;nbsp; | &amp;nbsp; 热度&amp;nbsp; <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>°C</span><br><span class="line">       <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="comment">&lt;!-- 在上面的位置加上如上代码 --&gt;</span>    </span><br><span class="line">   </span><br><span class="line">       </span><span class="template_tag">&#123;% <span class="keyword">if</span> post.comments %&#125;</span><span class="xml"></span><br><span class="line">         </span><span class="template_tag">&#123;% <span class="keyword">if</span> (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125;</span><span class="xml"></span><br><span class="line">           <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"post-comments-count"</span>&gt;</span></span><br><span class="line">             &amp;nbsp; | &amp;nbsp;</span><br><span class="line">             <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; url_for(post.path) &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">#comments"</span> <span class="attribute">itemprop</span>=<span class="value">"discussionUrl"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"post-comments-count ds-thread-count"</span> <span class="attribute">data-thread-key</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; post.path &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">itemprop</span>=<span class="value">"commentsCount"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E7%AB%992.jpg" alt=""></p>
<p>但是这有一个缺陷。就是我们会发现在主页时显示的热度和进入博客后的热度不一样，那是因为在主页时他显示的是主页这个页面的阅读量，而不是博客的阅读量，所以我们需要改变一些 (不会该代码的哭死╥﹏╥… )：<br>我们在<code>/themes/hexo-theme-next/layout/_macro/</code>目录下新建<code>post-article.swig</code>,把这些<code>post.swig</code>中的内容复制过去，而且加上上面的统计代码，然后在<code>/themes/hexo-theme-next/layout/post.swig</code>上面<code>% import &#39;_macro/post.swig&#39; as post_template %</code>中的<code>post.swig</code>改成<code>post-article.swig</code>，这样子就解决啦。就是在主页上的博客名字下面不会有阅读人数，进入博客才能看见。<br>为了给大家尽量详细的说明，不知不觉发现这篇文章写得好长^O^ ，下次接着写。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着我们开始丰富我们的博客。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第二站：部署到GitHub]]></title>
    <link href="http://prozhuchen.com/2015/09/30/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%BA%8C%E7%AB%99/"/>
    <id>http://prozhuchen.com/2015/09/30/Hexo博客第二站/</id>
    <published>2015-09-30T07:06:50.000Z</published>
    <updated>2016-12-30T12:57:23.170Z</updated>
    <content type="html"><![CDATA[<p>我们开始把Hexo博客部署在GitHub上。<a id="more"></a></p>
<p>首先声明一点，作为一个静态博客，Hexo不止能部署在Git上，只要支持Web访问的空间都可以存放Hexo静态博客。不过GitHub作为一个程序员聚居地，年轻的我们也需要靠近组织嘛。<br>在这里我们假设小伙伴都已经有了一个GitHub账号，并且有了一个GitHub博客。如果没有做的请看这里  &gt; <a href="http://blog.csdn.net/renfufei/article/details/37725057/" target="_blank" rel="external">GitHub博客搭建</a>。</p>
<p>注意：下面的命令在Git Bash上运行。</p>
<h1 id="1-_GitHub生成_SSH_key">1. GitHub生成 SSH key</h1><h2 id="1-1_生成_SSH_key">1.1 生成 SSH key</h2><p>作为第一步，首先得让我们的电脑连上GitHub。<br>输入<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>,接下来就是不断的敲回车就可以啦。</p>
<pre><code>ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span>
<span class="comment"># Creates a new ssh key, using the provided email as a label</span>
Generating public/<span class="keyword">private</span> rsa key pair.
Enter <span class="built_in">file</span> <span class="operator">in</span> which <span class="built_in">to</span> save <span class="operator">the</span> key (/Users/you/.ssh/id_rsa): [Press enter]
Enter passphrase (<span class="constant">empty</span> <span class="keyword">for</span> no passphrase): [Type <span class="operator">a</span> passphrase]
Enter same passphrase again: [Type passphrase again]
Your identification has been saved <span class="operator">in</span> /Users/you/.ssh/id_rsa.
Your public key has been saved <span class="operator">in</span> /Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
<span class="number">01</span>:<span class="number">0</span>f:f4:<span class="number">3</span>b:ca:<span class="number">85</span>:d6:<span class="number">17</span>:a1:<span class="number">7</span>d:f0:<span class="number">68</span>:<span class="number">9</span>d:f0:a2:db your_email@example.com
</code></pre><p>此时在你电脑的 <code>C:\Users\用户名\.ssh\</code>这个目录下就可以找到我们需要的SSH key - id_rsa.pub了。<br>此时在你的GitHub的settings里找到SSH keys，把id_rsa.pub里面的东西添加到Add an SSH key的key里面。<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/GitHub+Hexo静态博客第二站1.jpg" alt=""><br>然后在Git Bash里面输入<code>ssh -T git@github.com</code>:</p>
<pre><code>$ ssh -T git@github.com
Hi prozhuchen! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.
</code></pre><p>第一步成功！</p>
<h2 id="1-2_输入ssh_-T_git@github-com_时出现的错误">1.2 输入<code>ssh -T git@github.com</code> 时出现的错误</h2><ol>
<li>输入<code>ssh -T git@github.com</code>出现<code>Permission denied (publickey)</code><br>借鉴这篇博文 <a href="http://blog.csdn.net/sunnypotter/article/details/18948053" target="_blank" rel="external">git连接github失败的问题</a>。</li>
<li>出现<code>ssh:connect tohost github.com port22:Bad file number</code><br>可以看出是端口出现了问题，22是默认的ssh端口，但一般好像是关上的，所以我们改掉端口。<br>我们在SSH key的目录下(一般是<code>C:\Users\用户名\.ssh\</code>)新建一个config文件，内容是：</li>
</ol>
<pre><code>Host github<span class="class">.com</span>  
User fulinux@sina<span class="class">.com</span>  
Hostname ssh<span class="class">.github</span><span class="class">.com</span>  
PreferredAuthentications publickey  
IdentityFile  ~/.ssh/id_rsa  
Port  <span class="number">443</span>  
</code></pre><p>在此尝试连接，应该可以了。</p>
<h1 id="2-_Hexo部署到GitHub上">2. Hexo部署到GitHub上</h1><h2 id="2-1_Hexo部署">2.1 Hexo部署</h2><p>我们首先进入到Hexo的站点配置文件_config.yml，修改Deployment部分。</p>
<pre><code><span class="preprocessor"># Deployment</span>
<span class="preprocessor">## Docs: http://hexo.io/docs/deployment.html</span>
<span class="title">deploy</span>:
  <span class="typedef"><span class="keyword">type</span>: git</span>
  repo: git@github.com:prozhuchen/blog.git
  branch: gh-pages
</code></pre><p>这里的repo是你的GitHub博客的SSH地址,branch是你想部署在该仓库的分支。如果不知道自己博客的SSH地址的小伙伴看这里：<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/GitHub+Hexo静态博客第二站2.jpg" alt=""><br>当然了，你首先得点击<code>clone with HTTPS,SSH;</code>里面的SSH，然后框框里的就是你博客的SSH地址了。<br>然后输入：</p>
<pre><code>hexo <span class="keyword">g</span>
hexo <span class="literal">d</span>
</code></pre><p>可以看见：</p>
<pre><code>$ hexo d
INFO  Deploying: git
INFO  Clearing .deploy <span class="built_in">folder</span>...
INFO  Copying <span class="built_in">files</span> <span class="built_in">from</span> public <span class="built_in">folder</span>...
.....
Branch master <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch gh-pages <span class="built_in">from</span> git@github.com:prozhuchen/blog.git.
Everything up-<span class="built_in">to</span>-<span class="built_in">date</span>
INFO  Deploy done: git
</code></pre><p>此时去看你自己的GitHub博客吧~(地址应该是username.github.io或者是.com)。接下来我们来看看如果让我们的博客变得更完美了。</p>
<h2 id="2-2_输入hexo_d时出现的问题">2.2 输入<code>hexo d</code>时出现的问题</h2><ol>
<li><code>ERROR Deployer not found: git</code><ol>
<li>确定自己安装了hexo-deployer-git。如果没有,在Git Bash上输入：<code>npm install hexo-deployer-git --save</code>。</li>
<li>deploy的type的github需要改成git。</li>
<li>注意_config的配置写法。注意缩进，而且冒号后面要有一个空格。    </li>
</ol>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们开始把Hexo博客部署在GitHub上。]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://prozhuchen.com/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
      <category term="GitHub" scheme="http://prozhuchen.com/categories/Hexo/GitHub/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第一站：搭建本地Hexo静态博客]]></title>
    <link href="http://prozhuchen.com/2015/09/30/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%80%E7%AB%99/"/>
    <id>http://prozhuchen.com/2015/09/30/Hexo博客第一站/</id>
    <published>2015-09-30T06:06:28.000Z</published>
    <updated>2016-12-30T12:56:25.591Z</updated>
    <content type="html"><![CDATA[<p>首先我们先在本地搭一个静态的hexo博客。<a id="more"></a></p>
<h1 id="1-_Hexo的优势">1. <strong>Hexo的优势</strong></h1><p>Hexo是一款基于Node.js的静态博客，他的优势在于可以快速的搭建起一个个人博客，并且支持各种评论，分享等插件，最重要的是，它有很多现成的主题，你可以任意选择。</p>
<h1 id="2-_Hexo安装">2. <strong>Hexo安装</strong></h1><p>首先说明一点，此处的安装是在windows上的。linux的看这里: <a href="http://m.blog.csdn.net/blog/u012366161/42059813" target="_blank" rel="external">Ubuntu下用Hexo搭建个人博客</a></p>
<ol>
<li>安装Git. <a href="http://www.git-scm.com/download/" target="_blank" rel="external">Git安装地址</a></li>
<li>安装Node.js.  <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js安装地址</a><br>此时你点击任意文件夹右键，应该有 <code>Git Bash here</code>。进入后输入 <code>node -v</code>和 <code>npm -v</code>，如果显示版本号则安装成功。</li>
<li>安装Hexo.<br>在Git bash中输入 <code>npm install -g hexo</code>。</li>
<li>Hexo初始化。</li>
</ol>
<p>你可以cd到你选择的目录，然后输入</p>
<pre><code>hexo init
npm <span class="keyword">install</span>
</code></pre><p>或者直接输入</p>
<pre><code>hexo init 你选择的目录
npm <span class="keyword">install</span>
</code></pre><p>此时在你选择的目录下,输入 <code>hexo g</code> 和 <code>hexo s</code>。</p>
<pre><code>hexo g  <span class="comment">//生成静态网页</span>
INFO  Files loaded <span class="keyword">in</span> <span class="number">705</span> ms
INFO  Generated: js/script<span class="class">.js</span>
...
INFO  Generated: archives/<span class="number">2015</span>/<span class="number">09</span>/index<span class="class">.html</span>
INFO  Generated: index<span class="class">.html</span>
INFO  <span class="number">28</span> files generated <span class="keyword">in</span> <span class="number">1.95</span> s

hexo s  <span class="comment">//启动服务器</span>
INFO  Hexo is running at http:<span class="comment">//0.0.0.0:4000/. Press Ctrl+C to stop.</span>
</code></pre><p>此时你打开 <a href="http://127.0.0.1:4000/" target="_blank" rel="external">http://127.0.0.1:4000</a> , 就能看到已经生成的Hexo界面啦。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/hexo.jpg" alt=""></p>
<h1 id="3-_Hexo常用命令">3. Hexo常用命令</h1><p>这里先说一下Hexo常用的命令，接下来的文章也会提醒一些的。</p>
<pre><code><span class="variable">$ </span>hexo new [layout] &lt;title&gt; <span class="comment">#建立新文章，默认在_posts下，layout="draft"时发布的是草稿</span>
<span class="variable">$ </span>hexo publish &lt;filename&gt;   <span class="comment">#将_drafts下的文件放到_posts下，也就是发布草稿</span>
<span class="variable">$ </span>hexo generate             <span class="comment">#生成静态网页</span>
<span class="variable">$ </span>hexo server               <span class="comment">#启动预览服务器，开启-d选项时可以预览草稿</span>
<span class="variable">$ </span>hexo deploy               <span class="comment">#发布到远程服务器，开启--generate选项可以在deploy前自动generate</span>
</code></pre><p>另外这些命令都有简化命令，接下来我使用简化命令多一些。</p>
<pre><code><span class="variable">$ </span>hexo n  <span class="comment"># == hexo new</span>
<span class="variable">$ </span>hexo p  <span class="comment"># == hexo publish </span>
<span class="variable">$ </span>hexo g  <span class="comment"># == hexo generate</span>
<span class="variable">$ </span>hexo s  <span class="comment"># == hexo server</span>
<span class="variable">$ </span>hexo d  <span class="comment"># == hexo deploy</span>
</code></pre><hr>
<h1 id="4-_注意">4. <strong>注意</strong></h1><p>有的时候输入 <code>hexo init</code>看到了这句话：</p>
<pre><code>-<span class="string">bash:</span> <span class="string">hexo:</span> command not found
</code></pre><p>说明没找到hexo指令，此时我们找到hexo的下载目录，然后在系统变量path添加就可以了。我的目录是在 <code>C:\Users\用户名\AppData\Roaming\npm\node_modules\hexo\bin</code>。大家的应该也在类似位置。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先我们先在本地搭一个静态的hexo博客。]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://prozhuchen.com/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.com/categories/Hexo/"/>
    
  </entry>
  
</feed>
