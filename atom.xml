<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[朱琛的小屋]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://prozhuchen.github.io/"/>
  <updated>2015-10-03T08:38:48.143Z</updated>
  <id>http://prozhuchen.github.io/</id>
  
  <author>
    <name><![CDATA[朱琛]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[各种排序代码集合笔记]]></title>
    <link href="http://prozhuchen.github.io/2015/10/03/%E5%8E%9F-%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E9%9B%86%E5%90%88%E7%AC%94%E8%AE%B0/"/>
    <id>http://prozhuchen.github.io/2015/10/03/原-各种排序代码集合笔记/</id>
    <published>2015-10-03T08:38:11.000Z</published>
    <updated>2015-10-03T08:38:48.143Z</updated>
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *datatemp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		data[i]=datatemp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> temp,j;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">		temp = data[i];</span><br><span class="line">		<span class="keyword">if</span>(data[i]&lt;data[i-<span class="number">1</span>])&#123;</span><br><span class="line">			j = i-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(data[j]&gt;temp)&#123;</span><br><span class="line">				data[j+<span class="number">1</span>]=data[j];</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			data[j+<span class="number">1</span>]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"直接插入排序:\t"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  "</span>,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> *datatemp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		data[i]=datatemp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dk = n/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(dk&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//插入排序了下面是</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=dk;i&lt;n;i+=dk)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = data[i];</span><br><span class="line">			<span class="keyword">if</span>(data[i]&lt;data[i-dk])&#123;</span><br><span class="line">				<span class="keyword">int</span> j = i-dk;</span><br><span class="line">				<span class="keyword">while</span>(data[j]&gt;temp)&#123;</span><br><span class="line">					data[j+dk]=data[j];</span><br><span class="line">					j-=dk;</span><br><span class="line">				&#125;</span><br><span class="line">				data[j+dk]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dk/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"希尔排序:\t"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  "</span>,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QsortThird</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high ,<span class="keyword">int</span> *data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = data[low];</span><br><span class="line">	<span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high &amp;&amp; data[high]&gt;=temp)high--;</span><br><span class="line">		data[low]=data[high];</span><br><span class="line">		<span class="keyword">while</span>(data[low]&lt;=temp &amp;&amp; low&lt;high) low++;</span><br><span class="line">		data[high]=data[low];</span><br><span class="line">	&#125;</span><br><span class="line">	data[low]=temp;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QsortSecond</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high ,<span class="keyword">int</span> *data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = QsortThird(low,high,data);</span><br><span class="line">		QsortSecond(low,mid-<span class="number">1</span>,data);</span><br><span class="line">		QsortSecond(mid+<span class="number">1</span>,high,data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QsortFrist</span><span class="params">(<span class="keyword">int</span> *datatemp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		data[i]=datatemp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	QsortSecond(<span class="number">1</span>,n-<span class="number">1</span>,data);</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"快速排序:\t"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  "</span>,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high,<span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=low,m=mid,y=mid+<span class="number">1</span>,n=high;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=m &amp;&amp; y&lt;=n)&#123;</span><br><span class="line">		  <span class="keyword">if</span> (A[x] &lt;= A[y]) B[k++]=A[x++];</span><br><span class="line">		  <span class="keyword">else</span> B[k++]=A[y++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=m)&#123;</span><br><span class="line">		B[k++]=A[x++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(y&lt;=n)&#123;</span><br><span class="line">		B[k++]=A[y++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把已经有序的序列再返回</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)  </span><br><span class="line">        A[low+i] = B[i];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortSecond</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">			MergeSortSecond(A,low,mid,B);</span><br><span class="line">			MergeSortSecond(A,mid+<span class="number">1</span>,high,B);</span><br><span class="line">			Merge(A,low, mid, high, B); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortFirst</span><span class="params">(<span class="keyword">int</span> *datatemp,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		data[i]=datatemp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> *datatmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	MergeSortSecond(data,<span class="number">1</span>,n-<span class="number">1</span>,datatmp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"归并排序:\t"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  "</span>,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>&#125;;<span class="comment">//后七个数是数据，第一个是哨兵，这里为了做例子才这么写</span></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"原始数据:\t"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  "</span>,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	InsertSort(data,<span class="number">8</span>);</span><br><span class="line">	ShellSort(data,<span class="number">8</span>);</span><br><span class="line">	QsortFrist(data,<span class="number">8</span>);</span><br><span class="line">	MergeSortFirst(data,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还没写完，有空把堆排序补上。</p>
]]></content>
    <summary type="html">
    <![CDATA[各种排序代码集合]]>
    
    </summary>
    
      <category term="算法" scheme="http://prozhuchen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://prozhuchen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第五站：文章配置+Markdown语法]]></title>
    <link href="http://prozhuchen.github.io/2015/10/03/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%BA%94%E7%AB%99/"/>
    <id>http://prozhuchen.github.io/2015/10/03/Hexo博客第五站/</id>
    <published>2015-10-03T07:53:11.000Z</published>
    <updated>2015-10-03T09:51:10.172Z</updated>
    <content type="html"><![CDATA[<p>现在我们可以尽情写自己想写的东西了。但是首先我们得学会在哪写和怎么写。</p>
<h1 id="在哪写(Hexo_文章配置)">在哪写(Hexo 文章配置)</h1><h2 id="从别处迁移">从别处迁移</h2><p>如果我们之前在别的网站已经有了自己的博客，那当然不能直接扔掉啦，Hexo可以从RSS/Jekyll/Octopress/Wordpress迁移之前的博客（传送门 <a href="http://zespia.tw/hexo/docs/migration.html" target="_blank" rel="external">从别处迁移到Hexo</a>）。</p>
<h2 id="自己写">自己写</h2><p>首先我们在Git Bash中输入：</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"article name"</span>
</code></pre><p>然后我们在博客根目录<code>/source/_posts</code>下会看见新产生的<code>article name.md</code>。<br>如果我们想改变这个名字的格式，就可以在站点配置文件的31行左右改变<code>new_post_name</code>，下面将名字格式改成了类似这样的<code>2015-09-29-name.md</code>：</p>
<pre><code><span class="comment"># Writing</span>
<span class="symbol">new_post_name:</span> <span class="symbol">:year-</span><span class="symbol">:month-</span><span class="symbol">:day-</span><span class="symbol">:title</span>.md <span class="comment"># File name of new posts</span>
<span class="symbol">default_layout:</span> post
<span class="symbol">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span>
<span class="symbol">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span>
<span class="symbol">filename_case:</span> <span class="number">0</span>
<span class="symbol">render_drafts:</span> <span class="literal">false</span>
</code></pre><p>然后重新生成一篇文章，可以看到产生的是<code>2015-09-29-article name.md</code>吧。</p>
<p>此时我们进入这篇文章，可以看见：</p>
<pre><code>title: q                  //文章的名字
date: 2015-10-03 15:53:11 //你生成这篇文章的时间
<span class="header">tags:                     //文章的标签
---</span>
</code></pre><p>类似这样的开头属性还有：</p>
<pre><code>updated     修改日期        文件的修改日期    
comments    是否开启评论    <span class="function"><span class="title">true</span><span class="params">(默认)</span></span>   
tags        文章标签          
categories  文章分类    
permalink   url中的名字    文件名
description 文章摘要
</code></pre><p>举两个例子：</p>
<pre><code><span class="comment">//这个文章不允许别人评论，默认评论是开启的</span>
title: Hexo博客第二站：部署到GitHub
date: <span class="number">2015</span>-<span class="number">09</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">29</span>:<span class="number">48</span>
comments: <span class="literal">false</span>

<span class="comment">//这个文章有两个标签，属于两个类别</span>
title: Hexo博客第二站：部署到GitHub
date: <span class="number">2015</span>-<span class="number">09</span>-<span class="number">30</span> <span class="number">15</span>:<span class="number">06</span>:<span class="number">50</span>
tags:
- Hexo
- GitHub
categories:
- Hexo
- GitHub
</code></pre><p>接下来我们就可以在下面写自己的文章啦，但是文章要符合Markdown语法，MarkDown语法是啥子？我们要咋写啊？</p>
<h1 id="怎么写">怎么写</h1><blockquote>
<p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。</p>
</blockquote>
<p>网上有很多的Markdown软件，我用的是<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">作业部落</a>，感觉这个软件做的很不错。其他的也有一些人是用sublime+插件（传送门 <a href="http://www.jianshu.com/p/378338f10263" target="_blank" rel="external">sublime text 2 下的Markdown写作</a>），大家可以自己选择自己想要的。</p>
<p>至于Markdown语法，一开始准备自己写，但是后来发现有好多内容网上已经有了，再写出来会很重复。所以基本语法我就不提了。在这里说一些我在用Markdown时的心得。</p>
<ol>
<li>NexT主题有一个配置选项<code>toc_list_number: true</code>，这个选项使我们的目录会自动配上顺序标号，所以我们在自己写的时候可以不用带上了，如果不习惯的话，把这个配置注释掉即可。</li>
<li><p>在用Markdown写命令的时候，我们将命令缩进四个空格，就会出现下面的情况。</p>
<pre><code>命令
</code></pre></li>
</ol>
<p>绝大部分时候，一个Tab就是四个空格，当然你也可以设置，例如用sublime写作时，你就可以设定一个Tab等于多少空格。</p>
<ol>
<li><p>在用Markdown写代码的时候，我们只要用<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span>
```
</code></pre></li>
</ol>
<p>Markdown变得越来越流行，他的兼容性和可读性可以胜任各个场合，而且如果伴随着一些专业编辑器，我们的写作速度大大加快了。</p>
<p>从现在开始，大家可以开始自己的博客创作之路了！</p>
]]></content>
    <summary type="html">
    <![CDATA[我们来学习在哪写文章和怎么写文章。]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://prozhuchen.github.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第四站：搜索引擎+小插件+配置结构分析]]></title>
    <link href="http://prozhuchen.github.io/2015/10/03/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E5%9B%9B%E7%AB%99/"/>
    <id>http://prozhuchen.github.io/2015/10/03/Hexo博客第四站/</id>
    <published>2015-10-03T06:46:38.000Z</published>
    <updated>2015-10-03T08:08:13.072Z</updated>
    <content type="html"><![CDATA[<p>接着我们上次来继续加加加东西。</p>
<p>此时说明一下，大家可能看到我的博客和你们NexT主题显示的不一样，这是因为NexT主题包含两种主题，我们在主题配置文件中的40行左右可以看见：</p>
<pre><code><span class="preprocessor"># Schemes</span>
<span class="label">scheme:</span> Mist  <span class="preprocessor">#这一列默认是注释掉的，如果把这个取消注释，就会变成我的博客的主题样式。</span>
</code></pre><h1 id="搜索引擎">搜索引擎</h1><p>NexT主题支持了两种搜索引擎：Swiftype和微搜索。一个是国外的，一个是国内的。微搜索做的还不错，但是我搜索的时候总觉得有些延迟；至于Swiftype，真的真的很好用，良心厂家强力推荐。<br>有人说注册以后是30天试用，这个没关系，网站给的是30天高级账户的使用（那种有可以建立多个搜索引擎、多账户共同管理、一个引擎index多个域名的功能的账户），30天到期后你可选择花钱继续用这个高级账户（土豪自便），或者选择降级成为免费的账户类型，也就是我现在用的那种，所以，不用担心。<br>Swiftype网站的配置，网上其他好多的都是说的老版Swiftype的配置，比较落后了，这里提供给大家一位博主的博客，说的很详细。传送门　<a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html" target="_blank" rel="external">利用swiftype为hexo添加站内搜索</a>。<br>至于主题上的配置，我们只要在你的站点配置文件（不是主题配置文件）上加上这样一句话即可。</p>
<pre><code># <span class="keyword">Swiftype </span>Search Key
<span class="keyword">swiftype_key: </span>你的<span class="keyword">swiftype_key</span>
</code></pre><p>swiftype_key：在你Swiftype网站配置完后，我们看到了一个JS文件。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E5%9B%9B%E7%AB%991.jpg" alt=""><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">w,d,t,u,n,s,e</span>)</span>&#123;w[<span class="string">'SwiftypeObject'</span>]=n;w[n]=w[n]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(<span class="built_in">arguments</span>);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[<span class="number">0</span>];s.async=<span class="number">1</span>;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">'script'</span>,<span class="string">'//s.swiftypecdn.com/install/v2/st.js'</span>,<span class="string">'_st'</span>);</span><br><span class="line"></span><br><span class="line">  _st(<span class="string">'install'</span>,<span class="string">'yx9-swpbwqxuFPaTyCzz'</span>,<span class="string">'2.0.0'</span>);<span class="comment">//yx9-swpbwqxuFPaTyCzz 就是 swiftype_key，不同的人不一样。</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="安装插件RSS与_sitemap">安装插件RSS与 sitemap</h1><p>Sitemap:</p>
<blockquote>
<p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
</blockquote>
<p>这个Sitemap还是很有用的，例如本来你在google上搜索自己的新帖子是很难搜索到的，但是你向google提交sitemap后，自己的帖子变得容易搜索到多了。</p>
<p>RSS:</p>
<blockquote>
<p>RSS（Really Simple Syndication，简易信息聚合）是一种描述和同步网站内容的格式。你可以认为是一种定制个性化推送信息的服务。它能解决你漫无目的浏览网页的问题。它不会过时，信息越是过剩，它的意义也越加彰显。</p>
</blockquote>
<p>首先我们安装前人写好的插件。</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span>
npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span>
</code></pre><p>然后在站点配置文件上输入下面的语句：</p>
<pre><code><span class="attribute">plugins</span>:
- hexo-generator-feed
- hexo-generator-sitemap

<span class="attribute">sitemap</span>:
  <span class="attribute">path</span>: sitemap.xml

<span class="attribute">feed</span>:
  <span class="attribute">path</span>: atom.xml
</code></pre><p>上面的path说明了博客生成后的位置在根目录下，也是你访问网址是你的根地址+path。<br>此时你访问<code>http://127.0.0.1:4000/atom.xml</code>就能看到RSS的内容啦，sitemap访问同理。 如果想向google提交自己的sitemap，请看这个博客。传送门 <a href="http://fionat.github.io/blog/2013/10/23/sitemap/" target="_blank" rel="external">如何向google提交sitemap（详细）</a> ，过一天左右，你就能在google搜索到自己的新博客啦。</p>
<hr>
<h1 id="加入”关于我”_和DIY界面">加入”关于我” 和DIY界面</h1><p>一开始我们的主页里面只有主页，归档和标签三个标签。我们可以加一些自己DIY的界面。<br>我们在Git Bash中输入这样一句命令。</p>
<pre><code>hexo <span class="keyword">new</span> page <span class="string">"about"</span>
</code></pre><p>这时我们进入博客根目录下的<code>source</code>可以发现多了一个<code>about</code>文件夹，里面有一个<code>index.md</code>,此时我们进入主题配置文件（就是在主题目录下的_config.yml），对第五行进行更改。</p>
<pre><code><span class="attribute">menu</span>:
  <span class="attribute">home</span>: /
  #<span class="attribute">categories</span>: /categories
  <span class="attribute">about</span>: /about
  <span class="attribute">archives</span>: /archives
  <span class="attribute">tags</span>: /tags
  #<span class="attribute">commonweal</span>: /<span class="number">404</span>.html
</code></pre><p>此时再重新生成可以看见我们的页面多了一个关于的标签啦。<br>如果我们想加入一些新的标签，例如我上面出现的留言呢，可以再次这么敲命令：</p>
<pre><code>hexo <span class="keyword">new</span> page <span class="string">"guestbook"</span>
</code></pre><p>然后在主题配置文件进行更改，加一句 <code>guestbook: guestbook</code>。</p>
<pre><code><span class="attribute">menu</span>:
  <span class="attribute">home</span>: /
  #<span class="attribute">categories</span>: /categories
  <span class="attribute">about</span>: /about
  <span class="attribute">archives</span>: /archives
  <span class="attribute">tags</span>: /tags
  <span class="attribute">guestbook</span>: guestbook
  #<span class="attribute">commonweal</span>: /<span class="number">404</span>.html
</code></pre><p>此时我们重新生成发现页面上多出来的是guestbook，而不是我们想要的留言。这时候我们在<code>/themes/hexo-theme-next/languages/zh-Hans.yml</code>的目录下（这里默认你使用的是简体中文，若是其他语言更改相应的yml就行），在memu下加一句即可。</p>
<pre><code><span class="attribute">guestbook</span>: <span class="string">留言</span>
</code></pre><p>此时再重新生成可以看见我们的页面多了一个留言的标签啦。如果你想要其他的DIY标签，勇敢的去做吧！</p>
<hr>
<h1 id="主题配置文件结构分析">主题配置文件结构分析</h1><p>主题配置文件就是在主题目录下的_config.yml，这里对我们常用的配置进行一下讲解。</p>
<pre><code><span class="preprocessor"># when running hexo in a subdirectory (e.g. domain.tld/blog), remove leading slashes ( "/archives" -&gt; "archives" )</span>
menu:                         # 这是你主页最上面出现的标签
  home: /blog/
  archives: /blog/archives
  categories: /blog/categories
  tags: /blog/tags
  guestbook: /blog/guestbook
  # about: /blog/about
  # commonweal: /blog/<span class="number">404.</span>html

<span class="preprocessor"># Place your favicon.ico to /source directory.</span>
favicon: images/favicon.ico   #这是我们网站的图标

<span class="preprocessor"># Set default keywords (Use a comma to separate)</span>
keywords: <span class="string">"Hexo,next"</span>        

<span class="preprocessor"># Set rss to false to disable feed link.</span>
<span class="preprocessor"># Leave rss as empty to use site's feed link.</span>
<span class="preprocessor"># Set rss to specific value if you have burned your feed already.</span>
rss: /blog/atom.xml           #这是我们RSS的地址

<span class="preprocessor"># Icon fonts</span>
<span class="preprocessor"># Place your font into next/source/fonts, specify directory-name and font-name here</span>
<span class="preprocessor"># Avialable: default | linecons | fifty-shades | feather</span>
<span class="preprocessor">#icon_font: default           #这是我们图标字体的样式</span>
<span class="preprocessor"># icon_font: fifty-shades</span>
icon_font: feather
<span class="preprocessor">#icon_font: linecons</span>

<span class="preprocessor"># Code Highlight theme</span>
<span class="preprocessor"># Available value: normal | night | night eighties | night blue | night bright</span>
<span class="preprocessor"># https://github.com/chriskempson/tomorrow-theme</span>
highlight_theme: night eighties    #这是我们代码高亮的样式，你可以自己改变来看看每一种样式。


<span class="preprocessor"># MathJax Support</span>
mathjax: <span class="literal">true</span>          #显示数学公式的功能，默认是空，如果打开就设为<span class="literal">true</span>



<span class="preprocessor"># Schemes</span>
scheme: Mist    #NexT主题有两种主题，这里默认是注释掉的，取消注释的话就是我博客的样式。


<span class="preprocessor"># Sidebar, available value:</span>
<span class="preprocessor">#  - post    expand on posts automatically. Default.</span>
<span class="preprocessor">#  - always  expand for all pages automatically</span>
<span class="preprocessor">#  - hide    expand only when click on the sidebar toggle icon.</span>
sidebar: post     #这个是侧边栏的显示模式，默认是在阅读帖子的时候自动打开。
<span class="preprocessor">#sidebar: always</span>
<span class="preprocessor">#sidebar: hide</span>


<span class="preprocessor"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span>
scroll_to_more: <span class="literal">true</span>    #启动摘取一部分作为摘要，剩余的在阅读全文里。


<span class="preprocessor"># Automatically add list number to toc.</span>
toc_list_number: <span class="literal">true</span>   #自动在目录里加入列表数字
</code></pre><p>到现在基本的东西我们都算是有啦，现在可以准备开始写博客了。</p>
]]></content>
    <summary type="html">
    <![CDATA[接着我们上次来继续加加加东西。]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://prozhuchen.github.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第三站：安装主题+第三方评论+网站统计]]></title>
    <link href="http://prozhuchen.github.io/2015/10/01/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E7%AB%99/"/>
    <id>http://prozhuchen.github.io/2015/10/01/Hexo博客第三站/</id>
    <published>2015-10-01T15:14:50.000Z</published>
    <updated>2015-10-03T07:09:22.699Z</updated>
    <content type="html"><![CDATA[<p>接着我们开始丰富我们的博客。<a id="more"></a></p>
<p>再次提示：</p>
<ol>
<li>下面输入的命令都在 Git Bash 中输入。</li>
<li>下文提到的目录地址都是面对NexT主题的，不过其他主题的索引也都大同小异。</li>
</ol>
<h1 id="hexo博客结构">hexo博客结构</h1><p>在这里，我们先来看看hexo自动生成的博客的主要结构。</p>
<pre><code>├─scaffolds      <span class="comment">//每篇帖子模板所在地</span>
├─source         
│  └─_posts      <span class="comment">//这里放着我们写的帖子 里面初始化一篇hello-world.md</span>
└─themes         <span class="comment">//hexo博客主题所在地</span>
    └─landscape  <span class="comment">//初始化主题默认为landscape</span>
├─node_modules   <span class="comment">//hexo的驱动文件所在地</span>
├─_config<span class="class">.yml</span>    <span class="comment">//hexo博客配置文件</span>
</code></pre><p>这些都是我们有可能去改变的。看完了这个，接下来开始让我们的博客变得添砖加瓦吧。</p>
<h1 id="添砖加瓦">添砖加瓦</h1><h2 id="安装主题">安装主题</h2><p>一个好看的主题可以更加吸引读者，但是从头设计主题也太麻烦了吧~，所以Hexo有很多现成的主题。传送门 [ <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo主题</a> ]<br>我们利用语句下载下来我们需要的主题。例如我们下载<code>hexo-theme-next</code>这个主题。</p>
<pre><code><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/iissnan</span><span class="regexp">/hexo-theme-next.git themes/hexo</span>-theme-<span class="keyword">next</span>
</code></pre><p>然后进入上面提到的 themes 文件夹下，可以看见出现了hexo-theme-next文件夹。此时我们到博客根目录下的 _config.yml，修改博客所用的主题 (第66行) 。</p>
<pre><code><span class="preprocessor"># Extensions</span>
<span class="preprocessor">## Plugins: http://hexo.io/plugins/</span>
<span class="preprocessor">## Themes: http://hexo.io/themes/</span>
theme: hexo-theme-next
</code></pre><p>改完后，我们在 Git Bash 中输入</p>
<pre><code>hexo <span class="keyword">g</span>
hexo <span class="literal">s</span>
</code></pre><p>进入 [ <a href="http://127.0.0.1:4000/" target="_blank" rel="external">http://127.0.0.1:4000/</a> ] 查看我们的页面，是不是变得高大上多啦。这一章主要是完善博客所必须的一些内容，关于这个主题的小改变请看这里。[哈哈哈哈哈哈哈哈哈哈哈哈哈哈]</p>
<h2 id="第三方评论">第三方评论</h2><p>博客怎么能没有让小伙伴说话的地方呢。因为Hexo博客是静态博客，所以评论系统我们得靠其他的插件了。NexT这个主题支持 Disqus 和多说两种第三方评论插件。我使用的是多说。Disqus的看这里有提到  <a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo在github上构建免费的Web应用</a>。</p>
<ol>
<li>进入<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>平台，点击 “ 我要安装 “ 。</li>
<li>配置好自己的站点，注意多说域名这一栏是我们接下来需要的东西。站点地址就是你Hexo博客上传的GitHub页面地址。</li>
<li>在你的站点配置文件 (不是主题配置文件) _config.yml加一行：<code>duoshuo_shortname: 你的多说域名</code></li>
<li>再次生成上传 <code>hexo g</code>，<code>hexo d</code> （没有事先部署到GitHub上的看这里  <a href="http://prozhuchen.github.io/blog/2015/09/30/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%BA%8C%E7%AB%99/">Hexo博客第二站：部署到GitHub上</a>）,点击文章hello-world，是不是看见最下方出现了评论系统啦。管理的话进入多说的后台管理就行了。</li>
<li>**有人可能觉得多说的标准css样式不怎么好看。你可以进入后台管理-设置-基本设置-自定义CSS里面编辑自己想要的。我用的是从网上借鉴来的。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ds-reset</span> <span class="class">.ds-avatar</span> <span class="tag">img</span>,</span><br><span class="line"><span class="id">#ds-recent-visitors</span> <span class="class">.ds-avatar</span> <span class="tag">img</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">54px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">54px</span></span></span>;     <span class="comment">/*设置图像的长和宽，这里要根据自己的评论框情况更改*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">27px</span></span></span>;     <span class="comment">/*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-border-radius</span>:<span class="value"> <span class="number">27px</span></span></span>;     <span class="comment">/*圆角效果：兼容webkit浏览器*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-moz-border-radius</span>:<span class="value"> <span class="number">27px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="hexcolor">#3333</span>sf</span></span>;     <span class="comment">/*设置图像阴影效果*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-box-shadow</span>:<span class="value"> inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="hexcolor">#3333</span>sf</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value"> <span class="number">0.4s</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value"> -webkit-transform <span class="number">0.4s</span> ease-out</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">transition</span>:<span class="value"> transform <span class="number">0.4s</span> ease-out</span></span>;     <span class="comment">/*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-moz-transition</span>:<span class="value"> -moz-transform <span class="number">0.4s</span> ease-out</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#ds-reset</span> <span class="class">.ds-avatar</span> <span class="rule"><span class="attribute">img</span>:<span class="value">hover,</span><br><span class="line"><span class="hexcolor">#d</span>s-recent-visitors .ds-avatar img:hover &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置鼠标悬浮在头像时的CSS样式*/</span>    box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">  <span class="tag">rgba</span>(255, 255, 255, <span class="class">.6</span>), <span class="tag">inset</span> 0 0 20<span class="tag">px</span> <span class="tag">rgba</span>(255, 255, 255, 1);</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-box-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">  <span class="tag">rgba</span>(255, 255, 255, <span class="class">.6</span>), <span class="tag">inset</span> 0 0 20<span class="tag">px</span> <span class="tag">rgba</span>(255, 255, 255, 1);</span><br><span class="line">  <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotateZ</span>(<span class="number">360deg</span>)</span></span>;     <span class="comment">/*图像旋转360度*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">rotateZ</span>(<span class="number">360deg</span>)</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-moz-transform</span>:<span class="value"> <span class="function">rotateZ</span>(<span class="number">360deg</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="id">#ds-recent-visitors</span> <span class="class">.ds-avatar</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*隐藏多说底部版权*/</span></span><br><span class="line"><span class="hexcolor">#d</span>s-thread <span class="hexcolor">#d</span>s-reset .ds-powered-by &#123;</span><br><span class="line">  display: none</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="网站统计">网站统计</h2><p>其实我觉得google，百度统计这些对于许多人用不太上，毕竟不能直接观察到自己的博客有多少人看了什么的。如果需要安装的看这里&gt;<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E6%B7%BB%E5%8A%A0-Google---%E7%99%BE%E5%BA%A6-%E7%BB%9F%E8%AE%A1" target="_blank" rel="external">添加 Google, 百度统计</a>。这里推荐一个小插件-<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="external">不蒜子</a>。这个小插件可以让你轻而易举的看见自己的博客火热程度，例如访问量和访问人数等。<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E7%AB%991.jpg" alt=""><br>有一个好玩的小地方，你为了想看到每一篇文章的阅读量，你可以在<code>/themes/hexo-theme-next/layout/_macro/post.swig</code>里面的下面的位置加上如下代码，(这个热度是从一个博客上看到的，感觉很有趣哈):<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template_tag">&#123;% <span class="keyword">if</span> post.categories and post.categories.length %&#125;</span><span class="xml"></span><br><span class="line">         <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"post-category"</span> &gt;</span></span><br><span class="line">    </span><br><span class="line">         <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">       </span><span class="template_tag">&#123;% <span class="keyword">endif</span> %&#125;</span><span class="xml"></span><br><span class="line">       </span><br><span class="line">  <span class="comment">&lt;!-- 在下面的位置加上如下代码 --&gt;</span></span><br><span class="line">  </span><br><span class="line">       <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_container_page_pv"</span>&gt;</span></span><br><span class="line">       &amp;nbsp; | &amp;nbsp; 热度&amp;nbsp; <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>°C</span><br><span class="line">       <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="comment">&lt;!-- 在上面的位置加上如上代码 --&gt;</span>    </span><br><span class="line">   </span><br><span class="line">       </span><span class="template_tag">&#123;% <span class="keyword">if</span> post.comments %&#125;</span><span class="xml"></span><br><span class="line">         </span><span class="template_tag">&#123;% <span class="keyword">if</span> (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125;</span><span class="xml"></span><br><span class="line">           <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"post-comments-count"</span>&gt;</span></span><br><span class="line">             &amp;nbsp; | &amp;nbsp;</span><br><span class="line">             <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; url_for(post.path) &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">#comments"</span> <span class="attribute">itemprop</span>=<span class="value">"discussionUrl"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"post-comments-count ds-thread-count"</span> <span class="attribute">data-thread-key</span>=<span class="value">"</span></span></span><span class="variable">&#123;&#123; post.path &#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">itemprop</span>=<span class="value">"commentsCount"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E7%AB%992.jpg" alt=""></p>
<p>但是这有一个缺陷。就是我们会发现在主页时显示的热度和进入博客后的热度不一样，那是因为在主页时他显示的是主页这个页面的阅读量，而不是博客的阅读量，所以我们需要改变一些 (不会该代码的哭死╥﹏╥… )：<br>我们在<code>/themes/hexo-theme-next/layout/_macro/</code>目录下新建<code>post-article.swig</code>,把这些<code>post.swig</code>中的内容复制过去，而且加上上面的统计代码，然后在<code>/themes/hexo-theme-next/layout/post.swig</code>上面<code>% import &#39;_macro/post.swig&#39; as post_template %</code>中的<code>post.swig</code>改成<code>post-article.swig</code>，这样子就解决啦。就是在主页上的博客名字下面不会有阅读人数，进入博客才能看见。<br>为了给大家尽量详细的说明，不知不觉发现这篇文章写得好长^O^ ，下次接着写。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着我们开始丰富我们的博客。]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://prozhuchen.github.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第二站：部署到GitHub]]></title>
    <link href="http://prozhuchen.github.io/2015/09/30/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%BA%8C%E7%AB%99/"/>
    <id>http://prozhuchen.github.io/2015/09/30/Hexo博客第二站/</id>
    <published>2015-09-30T07:06:50.000Z</published>
    <updated>2015-10-03T06:50:13.013Z</updated>
    <content type="html"><![CDATA[<p>我们开始把Hexo博客部署在GitHub上。<a id="more"></a></p>
<p>首先声明一点，作为一个静态博客，Hexo不止能部署在Git上，只要支持Web访问的空间都可以存放Hexo静态博客。不过GitHub作为一个程序员聚居地，年轻的我们也需要靠近组织嘛。<br>在这里我们假设小伙伴都已经有了一个GitHub账号，并且有了一个GitHub博客。如果没有做的请看这里  &gt; <a href="http://blog.csdn.net/renfufei/article/details/37725057/" target="_blank" rel="external">GitHub博客搭建</a>。</p>
<p>注意：下面的命令在Git Bash上运行。</p>
<h1 id="GitHub生成_SSH_key">GitHub生成 SSH key</h1><h2 id="生成_SSH_key">生成 SSH key</h2><p>作为第一步，首先得让我们的电脑连上GitHub。<br>输入<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>,接下来就是不断的敲回车就可以啦。</p>
<pre><code>ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span>
<span class="comment"># Creates a new ssh key, using the provided email as a label</span>
Generating public/<span class="keyword">private</span> rsa key pair.
Enter <span class="built_in">file</span> <span class="operator">in</span> which <span class="built_in">to</span> save <span class="operator">the</span> key (/Users/you/.ssh/id_rsa): [Press enter]
Enter passphrase (<span class="constant">empty</span> <span class="keyword">for</span> no passphrase): [Type <span class="operator">a</span> passphrase]
Enter same passphrase again: [Type passphrase again]
Your identification has been saved <span class="operator">in</span> /Users/you/.ssh/id_rsa.
Your public key has been saved <span class="operator">in</span> /Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
<span class="number">01</span>:<span class="number">0</span>f:f4:<span class="number">3</span>b:ca:<span class="number">85</span>:d6:<span class="number">17</span>:a1:<span class="number">7</span>d:f0:<span class="number">68</span>:<span class="number">9</span>d:f0:a2:db your_email@example.com
</code></pre><p>此时在你电脑的 <code>C:\Users\用户名\.ssh\</code>这个目录下就可以找到我们需要的SSH key - id_rsa.pub了。<br>此时在你的GitHub的settings里找到SSH keys，把id_rsa.pub里面的东西添加到Add an SSH key的key里面。<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/GitHub+Hexo静态博客第二站1.jpg" alt=""><br>然后在Git Bash里面输入<code>ssh -T git@github.com</code>:</p>
<pre><code>$ ssh -T git@github.com
Hi prozhuchen! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.
</code></pre><p>第一步成功！</p>
<h2 id="输入ssh_-T_git@github-com_时出现的错误">输入<code>ssh -T git@github.com</code> 时出现的错误</h2><ol>
<li>输入<code>ssh -T git@github.com</code>出现<code>Permission denied (publickey)</code><br>借鉴这篇博文 <a href="http://blog.csdn.net/sunnypotter/article/details/18948053" target="_blank" rel="external">git连接github失败的问题</a>。</li>
<li>出现<code>ssh:connect tohost github.com port22:Bad file number</code><br>可以看出是端口出现了问题，22是默认的ssh端口，但一般好像是关上的，所以我们改掉端口。<br>我们在SSH key的目录下(一般是<code>C:\Users\用户名\.ssh\</code>)新建一个config文件，内容是：</li>
</ol>
<pre><code>    Host github<span class="class">.com</span>  
    User fulinux@sina<span class="class">.com</span>  
    Hostname ssh<span class="class">.github</span><span class="class">.com</span>  
    PreferredAuthentications publickey  
    IdentityFile~/.ssh/id_rsa  
    Port443  

在此尝试连接，应该可以了。
</code></pre><h1 id="Hexo部署到GitHub上">Hexo部署到GitHub上</h1><h2 id="Hexo部署">Hexo部署</h2><p>我们首先进入到Hexo的站点配置文件_config.yml，修改Deployment部分。</p>
<pre><code><span class="preprocessor"># Deployment</span>
<span class="preprocessor">## Docs: http://hexo.io/docs/deployment.html</span>
<span class="title">deploy</span>:
  <span class="typedef"><span class="keyword">type</span>: git</span>
  repo: git@github.com:prozhuchen/blog.git
  branch: gh-pages
</code></pre><p>这里的repo是你的GitHub博客的SSH地址,branch是你想部署在该仓库的分支。如果不知道自己博客的SSH地址的小伙伴看这里：<br><img src="http://7xn5ph.com1.z0.glb.clouddn.com/GitHub+Hexo静态博客第二站2.jpg" alt=""><br>当然了，你首先得点击<code>clone with HTTPS,SSH;</code>里面的SSH，然后框框里的就是你博客的SSH地址了。<br>然后输入：</p>
<pre><code>hexo <span class="keyword">g</span>
hexo <span class="literal">d</span>
</code></pre><p>可以看见：</p>
<pre><code>$ hexo d
INFO  Deploying: git
INFO  Clearing .deploy <span class="built_in">folder</span>...
INFO  Copying <span class="built_in">files</span> <span class="built_in">from</span> public <span class="built_in">folder</span>...
.....
Branch master <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch gh-pages <span class="built_in">from</span> git@github.com:prozhuchen/blog.git.
Everything up-<span class="built_in">to</span>-<span class="built_in">date</span>
INFO  Deploy done: git
</code></pre><p>此时去看你自己的GitHub博客吧~(地址应该是username.github.io或者是.com)。接下来我们来看看如果让我们的博客变得更完美了。</p>
<h2 id="输入hexo_d时出现的问题">输入<code>hexo d</code>时出现的问题</h2><ol>
<li><code>ERROR Deployer not found: git</code><ol>
<li>确定自己安装了hexo-deployer-git。如果没有,在Git Bash上输入：<code>npm install hexo-deployer-git --save</code>。</li>
<li>deploy的type的github需要改成git。</li>
<li>注意_config的配置写法。注意缩进，而且冒号后面要有一个空格。    </li>
</ol>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们开始把Hexo博客部署在GitHub上。]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://prozhuchen.github.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/categories/Hexo/"/>
    
      <category term="GitHub" scheme="http://prozhuchen.github.io/categories/Hexo/GitHub/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客第一站：搭建本地Hexo静态博客]]></title>
    <link href="http://prozhuchen.github.io/2015/09/30/Hexo%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%80%E7%AB%99/"/>
    <id>http://prozhuchen.github.io/2015/09/30/Hexo博客第一站/</id>
    <published>2015-09-30T06:06:28.000Z</published>
    <updated>2015-10-03T08:09:55.554Z</updated>
    <content type="html"><![CDATA[<p>首先我们先在本地搭一个静态的hexo博客。<a id="more"></a></p>
<h1 id="Hexo的优势"><strong>Hexo的优势</strong></h1><p>Hexo是一款基于Node.js的静态博客，他的优势在于可以快速的搭建起一个个人博客，并且支持各种评论，分享等插件，最重要的是，它有很多现成的主题，你可以任意选择。</p>
<h1 id="Hexo安装"><strong>Hexo安装</strong></h1><ol>
<li>安装Git. <a href="http://www.git-scm.com/download/" target="_blank" rel="external">Git安装地址</a></li>
<li>安装Node.js.  <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js安装地址</a><br>此时你点击任意文件夹右键，应该有 <code>Git Bash here</code>。进入后输入 <code>node -v</code>和 <code>npm -v</code>，如果显示版本号则安装成功。</li>
<li>安装Hexo.<br>在Git bash中输入 <code>npm install -g hexo</code>。</li>
<li>Hexo初始化。</li>
</ol>
<p>你可以cd到你选择的目录，然后输入</p>
<pre><code>hexo init
npm <span class="keyword">install</span>
</code></pre><p>或者直接输入</p>
<pre><code>hexo init 你选择的目录
npm <span class="keyword">install</span>
</code></pre><p>此时在你选择的目录下,输入 <code>hexo g</code> 和 <code>hexo s</code>。</p>
<pre><code>hexo g  <span class="comment">//生成静态网页</span>
INFO  Files loaded <span class="keyword">in</span> <span class="number">705</span> ms
INFO  Generated: js/script<span class="class">.js</span>
...
INFO  Generated: archives/<span class="number">2015</span>/<span class="number">09</span>/index<span class="class">.html</span>
INFO  Generated: index<span class="class">.html</span>
INFO  <span class="number">28</span> files generated <span class="keyword">in</span> <span class="number">1.95</span> s

hexo s  <span class="comment">//启动服务器</span>
INFO  Hexo is running at http:<span class="comment">//0.0.0.0:4000/. Press Ctrl+C to stop.</span>
</code></pre><p>此时你打开 <a href="http://127.0.0.1:4000/" target="_blank" rel="external">http://127.0.0.1:4000</a> , 就能看到已经生成的Hexo界面啦。</p>
<p><img src="http://7xn5ph.com1.z0.glb.clouddn.com/hexo.jpg" alt=""></p>
<h1 id="Hexo常用命令">Hexo常用命令</h1><p>这里先说一下Hexo常用的命令，接下来的文章也会提醒一些的。</p>
<pre><code><span class="variable">$ </span>hexo new [layout] &lt;title&gt; <span class="comment">#建立新文章，默认在_posts下，layout="draft"时发布的是草稿</span>
<span class="variable">$ </span>hexo publish &lt;filename&gt;   <span class="comment">#将_drafts下的文件放到_posts下，也就是发布草稿</span>
<span class="variable">$ </span>hexo generate             <span class="comment">#生成静态网页</span>
<span class="variable">$ </span>hexo server               <span class="comment">#启动预览服务器，开启-d选项时可以预览草稿</span>
<span class="variable">$ </span>hexo deploy               <span class="comment">#发布到远程服务器，开启--generate选项可以在deploy前自动generate</span>
</code></pre><p>另外这些命令都有简化命令，接下来我使用简化命令多一些。</p>
<pre><code><span class="variable">$ </span>hexo n  <span class="comment"># == hexo new</span>
<span class="variable">$ </span>hexo p  <span class="comment"># == hexo publish </span>
<span class="variable">$ </span>hexo g  <span class="comment"># == hexo generate</span>
<span class="variable">$ </span>hexo s  <span class="comment"># == hexo server</span>
<span class="variable">$ </span>hexo d  <span class="comment"># == hexo deploy</span>
</code></pre><hr>
<h1 id="注意"><strong>注意</strong></h1><p>有的时候输入 <code>hexo init</code>看到了这句话：</p>
<pre><code>-<span class="string">bash:</span> <span class="string">hexo:</span> command not found
</code></pre><p>说明没找到hexo指令，此时我们找到hexo的下载目录，然后在系统变量path添加就可以了。我的目录是在 <code>C:\Users\用户名\AppData\Roaming\npm\node_modules\hexo\bin</code>。大家的应该也在类似位置。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先我们先在本地搭一个静态的hexo博客。]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://prozhuchen.github.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://prozhuchen.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]人脸识别算法-特征脸方法（Eigenface）及python实现]]></title>
    <link href="http://prozhuchen.github.io/2015/06/08/%E5%8E%9F-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95-%E7%89%B9%E5%BE%81%E8%84%B8%E6%96%B9%E6%B3%95%EF%BC%88Eigenface%EF%BC%89%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/"/>
    <id>http://prozhuchen.github.io/2015/06/08/原-人脸识别算法-特征脸方法（Eigenface）及python实现/</id>
    <published>2015-06-08T12:15:20.000Z</published>
    <updated>2015-10-03T08:39:44.908Z</updated>
    <content type="html"><![CDATA[<p><span style="font-family:'Microsoft YaHei'; font-size:14px; background-color:inherit">这几天无聊，正好想起来以前谁说有同学做人脸识别，感觉好高大上，所以找来一些基础的人脸识别算法来自己实现一下，正好锻炼一下numpy的使用。</span></p>
<p><span style="color:rgb(51,51,51); background-color:inherit"><span style="font-family:'Microsoft YaHei'; font-size:14px; background-color:inherit">特征脸方法基本是将人脸识别推向真正可用的第一种方法，了解一下还是很有必要的。特征脸用到的理论基础PCA我在这里就不说了，百度一大堆，</span></span><span style="font-family:'Microsoft YaHei'; font-size:14px; color:rgb(51,51,51); line-height:1.5">主要讲一下实现步骤和自己在用python实现是发现的问题。这里我所使用的训练图片是YALE的人脸数据库</span><a href="http://cvc.yale.edu/projects/yalefaces/yalefaces.html" target="_blank" rel="external">点击打开链接</a><span style="font-family:'Microsoft YaHei'; font-size:14px; color:rgb(51,51,51); line-height:1.5">，这里面有15位志愿者的165张图片,包含光照,表情和姿态的变化。（我们做实验的时候就会发现，特征脸算法对光照敏感。）在unpadded文件夹下。每张图片的尺寸是98*116。</span></p>
<p><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"></span></span></p>
<p><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410141325667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></span></p>
<p></p>
<p><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></span></span></p>
<p></p>
<p><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px">特征脸实现步骤（大家如果英语好可以看看这个<a href="http://openbio.sourceforge.net/resources/eigenfaces/eigenfaces-html/facesOptions.html" target="_blank" rel="external">点击打开链接</a>）：</span></span></span></p>
<p><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"><span style="line-height:26px"><span style="font-size:18px; color:rgb(255,102,102)">1.</span><span style="color:rgb(51,51,51); font-size:14px"></span></span><span style="font-size:14px">获取包含M张人脸图像的集合<img src="http://img.blog.csdn.net/20150410162934184?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span><span style="font-size:14px; white-space:pre">。我们这里使用15张xxx.normal.pgm来作为人脸训练图像，所以这里M=15.我们把导入的图像拉平，</span></span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px; white-space:pre">本来是98<em>116的矩阵，我们拉平也就是一个11368</em>1的矩阵，然后M张放在一个大矩阵下，该矩阵为11368*15。</span></p>
<p><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">2.</span><span style="font-size:14px">我们计算平均图像<img src="http://img.blog.csdn.net/20150410162957666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">，并获得偏差矩阵<img src="http://img.blog.csdn.net/20150410163113634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">。</span><span style="font-size:14px">为11368*15.平均图像也就把每一行的15个元素平均计算，</span></span></span></p>
<p><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px">这样最后的平均图像就是一个我们所谓的大众脸。然后每张人脸都减去这个平均图像，最后得到。</span></span></p>
<p><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></span></p>
<p></p>
<p><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410162925717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></p>
<p></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410142234179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">3.</span><span style="font-size:14px">求得</span><span style="font-size:14px">的协方差矩阵</span><span style="font-size:14px">。并计算</span><span style="font-size:14px">的特征&#20540;和特征向量。这是标准的PCA算法流程。但是在这里一个很大的问题就是，协方差矩阵的维度会大到无法计算，例如我们这个</span><span style="font-size:14px; white-space:pre">11368<em>15的矩阵，它的协方差矩阵是11368</em>11368，这个计算量非常大，而且储存也很困难，所以有大神推导出了下面的方法：</span></span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">设&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>T</strong></span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;是预处理图像的矩阵，每一列对应一个减去均&#20540;图像之后的图像。则，协方差矩阵为&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>S</strong></span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;=&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>TT</strong></span><sup style="color:rgb(37,37,37); white-space:pre; line-height:1">T</sup><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;，并且对&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>S</strong></span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;的特征&#20540;分解为</span></span></p>
<p><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></span></p>
<dl style="margin-top:0.2em; margin-bottom:0.5em; color:rgb(37,37,37); line-height:22.3999996185303px"><br><dd style="line-height:1.5em; margin-left:1.6em; margin-bottom:0.1em; margin-right:0px"><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span><img src="http://upload.wikimedia.org/math/0/8/9/089510bbf395a5643ac323c3f340ad61.png" alt="\mathbf{Sv}_i = \mathbf{T}\mathbf{T}^T\mathbf{v}_i = \lambda_i \mathbf{v}_i"></span></dd></dl>

<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>然而，&nbsp;<strong>TT</strong><sup style="line-height:1">T</sup>&nbsp;是一个非常大的矩阵。因此，如果转而使用如下的特征&#20540;分解</span></p>
<dl style="margin-top:0.2em; margin-bottom:0.5em; color:rgb(37,37,37); line-height:22.3999996185303px"><br><dd style="line-height:1.5em; margin-left:1.6em; margin-bottom:0.1em; margin-right:0px"><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span><img src="http://upload.wikimedia.org/math/f/8/d/f8d1a3dcb5e14217cdfb237aabf1d618.png" alt="\mathbf{T}^T\mathbf{T}\mathbf{u}_i = \lambda_i \mathbf{u}_i"></span></dd></dl>

<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>此时，我们发现如果在等式两边乘以<strong>T</strong>，可得到</span></p>
<dl style="margin-top:0.2em; margin-bottom:0.5em; color:rgb(37,37,37); line-height:22.3999996185303px"><br><dd style="line-height:1.5em; margin-left:1.6em; margin-bottom:0.1em; margin-right:0px"><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span><img src="http://upload.wikimedia.org/math/6/d/b/6db92de9c64aab9ca466601c62098cee.png" alt="\mathbf{T}\mathbf{T}^T\mathbf{T}\mathbf{u}_i = \lambda_i \mathbf{T}\mathbf{u}_i"></span></dd></dl>

<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>这就意味着，如果&nbsp;<strong>u</strong><sub style="line-height:1">i</sub>&nbsp;是&nbsp;<strong>T</strong><sup style="line-height:1">T</sup><strong>T</strong>的一个特征向量，则&nbsp;<strong>v</strong><sub style="line-height:1">i</sub>&nbsp;=&nbsp;<strong>Tu</strong><sub style="line-height:1">i</sub>&nbsp;是&nbsp;<strong>S</strong>&nbsp;的一个特征向量。</span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>看懂上面这一些需要一些线性代数知识，这里的T 就是上面的偏差矩阵， 反正到最后我们得<span style="line-height:22.3999996185303px; white-space:pre"><strong>T</strong></span><sup style="white-space:pre; line-height:1">T</sup><span style="line-height:22.3999996185303px; white-space:pre"><strong>T</strong></span><span style="line-height:22.3999996185303px; white-space:pre">的一个特征向量，再用T与之相乘就是协方差矩阵的特征向量<img src="http://img.blog.csdn.net/20150410163122889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">。而此时我们求的特征向量是11368*15的矩阵，</span></span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:22.3999996185303px; white-space:pre">每一行（11368<em>1）如果变成图像大小矩阵（<span style="color:rgb(51,51,51); line-height:26px">98</span></em>116</span>）的话，都可以看做是一个新人脸，被称为特征脸。这里展现我试验中的其中一部分。</span></p>
<p><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410163312912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></p>
<p></p>
<p><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">4.</span><span style="color:rgb(37,37,37)"></span><span style="color:rgb(37,37,37); font-size:14px">主成分分析。在求得的特征向量</span><span style="color:rgb(37,37,37); font-size:14px">和特征&#20540;中，越大的特征&#20540;对于我们区分越重要，也就是我们说的主成分，我们只需要那些大的特征&#20540;对应的特征向量，</span></span></span></p>
<p><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="color:rgb(37,37,37); font-size:14px">而那些十分小甚至为0的特征&#20540;对于我们来说，对应的特征向量几乎没有意义。在这里我们通过一个阈&#20540;selecthr来控制，当排序后的特征&#20540;的一部分相加</span></span></span></p>
<p><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="color:rgb(37,37,37); font-size:14px">大于该阈&#20540;时，我们选择这部分特征&#20540;对应的特征向量，此时我们剩下的矩阵是11368*M’,M’根据情况在变化。 这样我们不仅减少了计算量，而且保留</span></span></span></p>
<p><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="color:rgb(37,37,37); font-size:14px">了主成分，减少了噪声的干扰。</span></span></span></p>
<p><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></span></p>
<p><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">5.</span><span style="font-size:14px">这一步就是开始进行人脸识别了。此时我们导入一个新的人脸</span><span style="font-size:14px">，我们使用上面主成分分析后得到的特征向量</span><span style="line-height:22.3999996185303px"><img src="http://img.blog.csdn.net/20150410163122889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">，来求得一个每一个特征向量对于导入人脸的权重向量<img src="http://img.blog.csdn.net/20150410163609817?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">。</span></span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410163315240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></p>
<p></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">这里的<img src="http://img.blog.csdn.net/20150410163436310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">就是上面第2步求得的平均图像。&nbsp;特征向量其实就是训练集合的图像与均&#20540;图像在该方向上的偏差，通过未知人脸在特征向量的投影，我们就可以知道未知人脸与平均图像在不同方向上的差距。此时我们用上面第2步我们求得的偏差矩阵的每一行做这样的处理，每一行都会得到一个<span style="white-space:pre"></span>权重向量。我们利用求得<img src="http://img.blog.csdn.net/20150410163558319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">与<img src="http://img.blog.csdn.net/20150410163535703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">的欧式距离来判断未知人脸与第k张训练人脸之间的差距。</span></p>
<p><img src="http://img.blog.csdn.net/20150410163428326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span></span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">在这里因为我假设我要识别的未知人肯定是训练集合里有的，所以我通过比较<img src="http://img.blog.csdn.net/20150410163616434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">，选择最小的k就是这个人脸对应的训练集合的脸。实际上，一般都是设定距离阈&#20540;，当距离小于阈&#20540;时说明要判别的脸和训练集内的第k个脸是同一个人的。当遍历所有训练集都大于阈&#20540;时，根据距离&#20540;的大小又可分为是新的人脸或者不是人脸的两种情况。根据训练集的不同，阈&#20540;设定并不是固定的。</span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></p>
<p></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">最后附上python代码，这里的&nbsp;ReconginitionVector函数就是求得特征向量的函数，就是按照上面说的顺序写下来的，judgeFace函数用来识别人脸。（大家可以借鉴一下，如果发现有什么不对的欢迎讨论）：</span></p>
<pre name="code" class="python">#coding:utf-8
from numpy import *
from numpy import linalg as la
import cv2
import os

def loadImageSet(add):
    FaceMat = mat(zeros((15,98*116)))
    j =0
    for i in os.listdir(add):
        if i.split(&#39;.&#39;)[1] == &#39;normal&#39;:
            try:
                img = cv2.imread(add+i,0)
            except:
                print &#39;load %s failed&#39;%i
            FaceMat[j,:] = mat(img).flatten()
            j += 1
    return FaceMat

def ReconginitionVector(selecthr = 0.8):
    # step1: load the face image data ,get the matrix consists of all image
    FaceMat = loadImageSet(&#39;D:\python/face recongnition\YALE\YALE\unpadded/&#39;).T
    # step2: average the FaceMat
    avgImg = mean(FaceMat,1)
    # step3: calculate the difference of avgimg and all image data(FaceMat)
    diffTrain = FaceMat-avgImg
    #step4: calculate eigenvector of covariance matrix (because covariance matrix will cause memory error)
    eigvals,eigVects = linalg.eig(mat(diffTrain.T*diffTrain))
    eigSortIndex = argsort(-eigvals)
    for i in xrange(shape(FaceMat)[1]):
        if (eigvals[eigSortIndex[:i]]/eigvals.sum()).sum() &gt;= selecthr:
            eigSortIndex = eigSortIndex[:i]
            break
    covVects = diffTrain * eigVects[:,eigSortIndex] # covVects is the eigenvector of covariance matrix
    # avgImg 是均值图像，covVects是协方差矩阵的特征向量，diffTrain是偏差矩阵
    return avgImg,covVects,diffTrain

def judgeFace(judgeImg,FaceVector,avgImg,diffTrain):
    diff = judgeImg.T - avgImg
    weiVec = FaceVector.T* diff
    res = 0
    resVal = inf
    for i in range(15):
        TrainVec = FaceVector.T*diffTrain[:,i]
        if  (array(weiVec-TrainVec)**2).sum() &lt; resVal:
            res =  i
            resVal = (array(weiVec-TrainVec)**2).sum()
    return res+1

if __name__ == &#39;__main__&#39;:

    avgImg,FaceVector,diffTrain = ReconginitionVector(selecthr = 0.9)
    nameList = [&#39;01&#39;,&#39;02&#39;,&#39;03&#39;,&#39;04&#39;,&#39;05&#39;,&#39;06&#39;,&#39;07&#39;,&#39;08&#39;,&#39;09&#39;,&#39;10&#39;,&#39;11&#39;,&#39;12&#39;,&#39;13&#39;,&#39;14&#39;,&#39;15&#39;]
    characteristic = [&#39;centerlight&#39;,&#39;glasses&#39;,&#39;happy&#39;,&#39;leftlight&#39;,&#39;noglasses&#39;,&#39;rightlight&#39;,&#39;sad&#39;,&#39;sleepy&#39;,&#39;surprised&#39;,&#39;wink&#39;]

    for c in characteristic:

        count = 0
        for i in range(len(nameList)):

            # 这里的loadname就是我们要识别的未知人脸图，我们通过15张未知人脸找出的对应训练人脸进行对比来求出正确率
            loadname = &#39;D:\python/face recongnition\YALE\YALE\unpadded\subject&#39;+nameList[i]+&#39;.&#39;+c+&#39;.pgm&#39;
            judgeImg = cv2.imread(loadname,0)
            if judgeFace(mat(judgeImg).flatten(),FaceVector,avgImg,diffTrain) == int(nameList[i]):
                count += 1
        print &#39;accuracy of %s is %f&#39;%(c, float(count)/len(nameList))  # 求出正确率
</pre>

<p><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></p>
<p></p>
<p><span style="white-space:pre"></span></p>
<div style="top:0px"><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px; background-color:inherit">这几天无聊，正好想起来以前谁说有同学做人脸识别，感觉好高大上，所以找来一些基础的人脸识别算法来自己实现一下，正好锻炼一下numpy的使用。</span><br><br><span style="color:rgb(51,51,51); background-color:inherit"><span style="font-family:'Microsoft YaHei'; font-size:14px; background-color:inherit">特征脸方法基本是将人脸识别推向真正可用的第一种方法，了解一下还是很有必要的。特征脸用到的理论基础PCA我在这里就不说了，百度一大堆，</span></span><span style="font-family:'Microsoft YaHei'; font-size:14px; color:rgb(51,51,51); line-height:1.5">主要讲一下实现步骤和自己在用python实现是发现的问题。这里我所使用的训练图片是YALE的人脸数据库</span><a href="http://cvc.yale.edu/projects/yalefaces/yalefaces.html" target="_blank" rel="external">点击打开链接</a><span style="font-family:'Microsoft YaHei'; font-size:14px; color:rgb(51,51,51); line-height:1.5">，这里面有15位志愿者的165张图片,包含光照,表情和姿态的变化。（我们做实验的时候就会发现，特征脸算法对光照敏感。）在unpadded文件夹下。每张图片的尺寸是98<em>116。</em></span><br><br><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"></span></span><br><br><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410141325667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></span></span></span><br><br><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><br><br></span></span></span><br><br><span style="white-space:pre"><span style="color:rgb(51,51,51); line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px">特征脸实现步骤（大家如果英语好可以看看这个<a href="http://openbio.sourceforge.net/resources/eigenfaces/eigenfaces-html/facesOptions.html" target="_blank" rel="external">点击打开链接</a>）：</span></span></span><br><br><span style="font-family:'Microsoft YaHei'"><span style="white-space:pre"><span style="line-height:26px"><span style="font-size:18px; color:rgb(255,102,102)">1.</span><span style="color:rgb(51,51,51); font-size:14px"></span></span><span style="font-size:14px">获取包含M张人脸图像的集合<img src="http://img.blog.csdn.net/20150410162934184?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span><span style="font-size:14px; white-space:pre">。我们这里使用15张xxx.normal.pgm来作为人脸训练图像，所以这里M=15.我们把导入的图像拉平，</span></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px; white-space:pre">本来是98116的矩阵，我们拉平也就是一个11368<em>1的矩阵，然后M张放在一个大矩阵下，该矩阵为11368</em>15。</span><br><br><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">2.</span><span style="font-size:14px">我们计算平均图像<img src="http://img.blog.csdn.net/20150410162957666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">，并获得偏差矩阵<img src="http://img.blog.csdn.net/20150410163113634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">。</span><span style="font-size:14px">为11368<em>15.平均图像也就把每一行的15个元素平均计算，</em></span></span></span><br><br><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px">这样最后的平均图像就是一个我们所谓的大众脸。然后每张人脸都减去这个平均图像，最后得到。</span></span><br><br><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><br><br></span></span><br><br><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410162925717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></span></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410142234179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><br><br><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">3.</span><span style="font-size:14px">求得</span><span style="font-size:14px">的协方差矩阵</span><span style="font-size:14px">。并计算</span><span style="font-size:14px">的特征&#20540;和特征向量。这是标准的PCA算法流程。但是在这里一个很大的问题就是，协方差矩阵的维度会大到无法计算，例如我们这个</span><span style="font-size:14px; white-space:pre">1136815的矩阵，它的协方差矩阵是11368<em>11368，这个计算量非常大，而且储存也很困难，所以有大神推导出了下面的方法：</em></span></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">设&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>T</strong></span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;是预处理图像的矩阵，每一列对应一个减去均&#20540;图像之后的图像。则，协方差矩阵为&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>S</strong></span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;=&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>TT</strong></span><sup style="color:rgb(37,37,37); white-space:pre; line-height:1">T</sup><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;，并且对&nbsp;</span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre"><strong>S</strong></span><span style="color:rgb(37,37,37); line-height:22.3999996185303px; white-space:pre">&nbsp;的特征&#20540;分解为</span></span><br><br><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></span><br><br><dl style="margin-top:0.2em; margin-bottom:0.5em; color:rgb(37,37,37); line-height:22.3999996185303px"><br><dd style="line-height:1.5em; margin-left:1.6em; margin-bottom:0.1em; margin-right:0px"><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span><img src="http://upload.wikimedia.org/math/0/8/9/089510bbf395a5643ac323c3f340ad61.png" alt="\mathbf{Sv}_i = \mathbf{T}\mathbf{T}^T\mathbf{v}_i = \lambda_i \mathbf{v}_i"></span></dd></dl><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>然而，&nbsp;<strong>TT</strong><sup style="line-height:1">T</sup>&nbsp;是一个非常大的矩阵。因此，如果转而使用如下的特征&#20540;分解</span><br><br><dl style="margin-top:0.2em; margin-bottom:0.5em; color:rgb(37,37,37); line-height:22.3999996185303px"><br><dd style="line-height:1.5em; margin-left:1.6em; margin-bottom:0.1em; margin-right:0px"><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span><img src="http://upload.wikimedia.org/math/f/8/d/f8d1a3dcb5e14217cdfb237aabf1d618.png" alt="\mathbf{T}^T\mathbf{T}\mathbf{u}_i = \lambda_i \mathbf{u}_i"></span></dd></dl><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>此时，我们发现如果在等式两边乘以<strong>T</strong>，可得到</span><br><br><dl style="margin-top:0.2em; margin-bottom:0.5em; color:rgb(37,37,37); line-height:22.3999996185303px"><br><dd style="line-height:1.5em; margin-left:1.6em; margin-bottom:0.1em; margin-right:0px"><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span><img src="http://upload.wikimedia.org/math/6/d/b/6db92de9c64aab9ca466601c62098cee.png" alt="\mathbf{T}\mathbf{T}^T\mathbf{T}\mathbf{u}_i = \lambda_i \mathbf{T}\mathbf{u}_i"></span></dd></dl><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>这就意味着，如果&nbsp;<strong>u</strong><sub style="line-height:1">i</sub>&nbsp;是&nbsp;<strong>T</strong><sup style="line-height:1">T</sup><strong>T</strong>的一个特征向量，则&nbsp;<strong>v</strong><sub style="line-height:1">i</sub>&nbsp;=&nbsp;<strong>Tu</strong><sub style="line-height:1">i</sub>&nbsp;是&nbsp;<strong>S</strong>&nbsp;的一个特征向量。</span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>看懂上面这一些需要一些线性代数知识，这里的T 就是上面的偏差矩阵， 反正到最后我们得<span style="line-height:22.3999996185303px; white-space:pre"><strong>T</strong></span><sup style="white-space:pre; line-height:1">T</sup><span style="line-height:22.3999996185303px; white-space:pre"><strong>T</strong></span><span style="line-height:22.3999996185303px; white-space:pre">的一个特征向量，再用T与之相乘就是协方差矩阵的特征向量<img src="http://img.blog.csdn.net/20150410163122889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">。而此时我们求的特征向量是1136815的矩阵，</span></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:22.3999996185303px; white-space:pre">每一行（11368<em>1）如果变成图像大小矩阵（<span style="color:rgb(51,51,51); line-height:26px">98</span></em>116</span>）的话，都可以看做是一个新人脸，被称为特征脸。这里展现我试验中的其中一部分。</span><br><br><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410163312912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></span></span><br><br><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">4.</span><span style="color:rgb(37,37,37)"></span><span style="color:rgb(37,37,37); font-size:14px">主成分分析。在求得的特征向量</span><span style="color:rgb(37,37,37); font-size:14px">和特征&#20540;中，越大的特征&#20540;对于我们区分越重要，也就是我们说的主成分，我们只需要那些大的特征&#20540;对应的特征向量，</span></span></span><br><br><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="color:rgb(37,37,37); font-size:14px">而那些十分小甚至为0的特征&#20540;对于我们来说，对应的特征向量几乎没有意义。在这里我们通过一个阈&#20540;selecthr来控制，当排序后的特征&#20540;的一部分相加</span></span></span><br><br><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="color:rgb(37,37,37); font-size:14px">大于该阈&#20540;时，我们选择这部分特征&#20540;对应的特征向量，此时我们剩下的矩阵是11368<em>M’,M’根据情况在变化。 这样我们不仅减少了计算量，而且保留</em></span></span></span><br><br><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'"><span style="color:rgb(37,37,37); font-size:14px">了主成分，减少了噪声的干扰。</span></span></span><br><br><span style="line-height:22.3999996185303px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></span><br><br><span style="font-family:'Microsoft YaHei'"><span style="font-size:18px; color:rgb(255,0,0)">5.</span><span style="font-size:14px">这一步就是开始进行人脸识别了。此时我们导入一个新的人脸</span><span style="font-size:14px">，我们使用上面主成分分析后得到的特征向量</span><span style="line-height:22.3999996185303px"><img src="http://img.blog.csdn.net/20150410163122889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">，来求得一个每一个特征向量对于导入人脸的权重向量<img src="http://img.blog.csdn.net/20150410163609817?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span><span style="font-size:14px">。</span></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150410163315240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px">这里的<img src="http://img.blog.csdn.net/20150410163436310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">就是上面第2步求得的平均图像。&nbsp;特征向量其实就是训练集合的图像与均&#20540;图像在该方向上的偏差，通过未知人脸在特征向量的投影，我们就可以知道未知人脸与平均图像在不同方向上的差距。此时我们用上面第2步我们求得的偏差矩阵的每一行做这样的处理，每一行都会得到一个<span style="white-space:pre"></span>权重向量。我们利用求得<img src="http://img.blog.csdn.net/20150410163558319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">与<img src="http://img.blog.csdn.net/20150410163535703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">的欧式距离来判断未知人脸与第k张训练人脸之间的差距。</span><br><br><img src="http://img.blog.csdn.net/20150410163428326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px">在这里因为我假设我要识别的未知人肯定是训练集合里有的，所以我通过比较<img src="http://img.blog.csdn.net/20150410163616434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">，选择最小的k就是这个人脸对应的训练集合的脸。实际上，一般都是设定距离阈&#20540;，当距离小于阈&#20540;时说明要判别的脸和训练集内的第k个脸是同一个人的。当遍历所有训练集都大于阈&#20540;时，根据距离&#20540;的大小又可分为是新的人脸或者不是人脸的两种情况。根据训练集的不同，阈&#20540;设定并不是固定的。</span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><br><br></span><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px">最后附上python代码，这里的&nbsp;ReconginitionVector函数就是求得特征向量的函数，就是按照上面说的顺序写下来的，judgeFace函数用来识别人脸。（大家可以借鉴一下，如果发现有什么不对的欢迎讨论）：</span><br><br><pre name="code" class="python">#coding:utf-8<br>from numpy import <br>from numpy import linalg as la<br>import cv2<br>import os<br><br>def loadImageSet(add):<br>    FaceMat = mat(zeros((15,98<em>116)))<br>    j =0<br>    for i in os.listdir(add):<br>        if i.split(&#39;.&#39;)[1] == &#39;normal&#39;:<br>            try:<br>                img = cv2.imread(add+i,0)<br>            except:<br>                print &#39;load %s failed&#39;%i<br>            FaceMat[j,:] = mat(img).flatten()<br>            j += 1<br>    return FaceMat<br><br>def ReconginitionVector(selecthr = 0.8):<br>    # step1: load the face image data ,get the matrix consists of all image<br>    FaceMat = loadImageSet(&#39;D:\python/face recongnition\YALE\YALE\unpadded/&#39;).T<br>    # step2: average the FaceMat<br>    avgImg = mean(FaceMat,1)<br>    # step3: calculate the difference of avgimg and all image data(FaceMat)<br>    diffTrain = FaceMat-avgImg<br>    #step4: calculate eigenvector of covariance matrix (because covariance matrix will cause memory error)<br>    eigvals,eigVects = linalg.eig(mat(diffTrain.T</em>diffTrain))<br>    eigSortIndex = argsort(-eigvals)<br>    for i in xrange(shape(FaceMat)[1]):<br>        if (eigvals[eigSortIndex[:i]]/eigvals.sum()).sum() &gt;= selecthr:<br>            eigSortIndex = eigSortIndex[:i]<br>            break<br>    covVects = diffTrain <em> eigVects[:,eigSortIndex] # covVects is the eigenvector of covariance matrix<br>    # avgImg 是均值图像，covVects是协方差矩阵的特征向量，diffTrain是偏差矩阵<br>    return avgImg,covVects,diffTrain<br><br>def judgeFace(judgeImg,FaceVector,avgImg,diffTrain):<br>    diff = judgeImg.T - avgImg<br>    weiVec = FaceVector.T</em> diff<br>    res = 0<br>    resVal = inf<br>    for i in range(15):<br>        TrainVec = FaceVector.T<em>diffTrain[:,i]<br>        if  (array(weiVec-TrainVec)<em>*2).sum() &lt; resVal:<br>            res =  i<br>            resVal = (array(weiVec-TrainVec)</em></em>2).sum()<br>    return res+1<br><br>if <strong>name</strong> == &#39;<strong>main</strong>&#39;:<br><br>    avgImg,FaceVector,diffTrain = ReconginitionVector(selecthr = 0.9)<br>    nameList = [&#39;01&#39;,&#39;02&#39;,&#39;03&#39;,&#39;04&#39;,&#39;05&#39;,&#39;06&#39;,&#39;07&#39;,&#39;08&#39;,&#39;09&#39;,&#39;10&#39;,&#39;11&#39;,&#39;12&#39;,&#39;13&#39;,&#39;14&#39;,&#39;15&#39;]<br>    characteristic = [&#39;centerlight&#39;,&#39;glasses&#39;,&#39;happy&#39;,&#39;leftlight&#39;,&#39;noglasses&#39;,&#39;rightlight&#39;,&#39;sad&#39;,&#39;sleepy&#39;,&#39;surprised&#39;,&#39;wink&#39;]<br><br>    for c in characteristic:<br><br>        count = 0<br>        for i in range(len(nameList)):<br><br>            # 这里的loadname就是我们要识别的未知人脸图，我们通过15张未知人脸找出的对应训练人脸进行对比来求出正确率<br>            loadname = &#39;D:\python/face recongnition\YALE\YALE\unpadded\subject&#39;+nameList[i]+&#39;.&#39;+c+&#39;.pgm&#39;<br>            judgeImg = cv2.imread(loadname,0)<br>            if judgeFace(mat(judgeImg).flatten(),FaceVector,avgImg,diffTrain) == int(nameList[i]):<br>                count += 1<br>        print &#39;accuracy of %s is %f&#39;%(c, float(count)/len(nameList))  # 求出正确率<br></pre><br><br><span style="font-family:'Microsoft YaHei'; font-size:14px"><br><br></span><br><br><span style="white-space:pre"></span><br><br></div>

]]></content>
    <summary type="html">
    <![CDATA[<p><span style="font-family:'Microsoft YaHei'; font-size:14px; background-color:inherit">这几天无聊，正好想起来以前谁说有同学做人脸识别，感觉好高大上，所以找来一些基础的人脸识别算法来自己实现]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]人脸识别算法-LBP算法及python实现]]></title>
    <link href="http://prozhuchen.github.io/2015/06/08/%E5%8E%9F-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95-LBP%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/"/>
    <id>http://prozhuchen.github.io/2015/06/08/原-人脸识别算法-LBP算法及python实现/</id>
    <published>2015-06-08T12:12:40.000Z</published>
    <updated>2015-10-03T08:39:33.548Z</updated>
    <content type="html"><![CDATA[<p><span style="font-family:'Microsoft YaHei'; font-size:14px">上一次我们说了<a href="http://blog.csdn.net/u010006643/article/details/44978755" target="_blank" rel="external">人脸识别算法-特征脸方法（Eigenface）及python实现</a>，在这一次，我们来看一看LBP算法。<span style="color:rgb(51,51,51); line-height:26px">相比于特征脸方法，LBP的识别率已经有了很大的提升。</span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>在这里，我们用的数据库和上次一样，都是UCI的<span style="line-height:19.0909080505371px">YALE的人脸数据库。</span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>因为我也是一边学一边写代码，所以害怕有人说我博文是抄袭的，所以在这里说明，我这里的算法思想主要是来自<a href="http://blog.csdn.net/feirose/article/details/39552977" target="_blank" rel="external">点击打开链接</a>（不过大家都是学习，应该不会这么计较吧），我主要是从实现的角度来说明一下在实现遇见的问题以及方法。</span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>LBP算法介绍：</span></span></span></p>
<h3 id="1-圆形LBP算子"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:19.0909080505371px"><span style="color:rgb(255,102,102)">1.</span></span><span style="color:rgb(51,51,51); line-height:19.0909080505371px">圆形LBP算子</span></span></h3><p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>在这个算法一开始的时候，大家使用的是最普通的八邻域算子。</span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150414193723453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>八邻域的像素&#20540;大于中心点&#20540;的标注1，反之标注0.这样我们就会得到一个八位数。这时我们从左上角开始算最高位，最后左边的为最低位，在这个图中就是00010011，换算十进制就是19，我们就把这个&#20540;作为中心点的LBP算子&#20540;。</span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>但是随着算法的发展，大家发现这个算子太过死板，<span style="line-height:26px">不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对<br> LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域。</span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="line-height:26px"><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150414194118580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></span></span></span></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="line-height:26px"><span style="white-space:pre"></span></span></span></span><span style="color:rgb(51,51,51); line-height:26px; white-space:pre">为什么</span><span style="color:rgb(51,51,51); line-height:26px">说圆形算子比八邻域算子要更好呢？从直观的角度来说，我们看下面的图</span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="line-height:26px"><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150414194446747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre">看</span>第一个图是不是很像脸部的右下巴部分，第二图像头部右上方额头？（好吧，如果不像的话，就自己感受一下吧，，个人感觉）</span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="line-height:26px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>这时我们假设在半径为R的圆形邻域内有P个采样点的算子，上面的图是在R = 2，P=8. 此时我们算每个采样点的坐标：</span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="line-height:26px"><span style="white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150414195003876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">、</span></span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>xp 是p点的x坐标，yp是y坐标，p的取&#20540;范围（0，P-1）（俗称0,1,2,3,4,5,6,7）。 但此时我们这样得到的不一定是整数，<span style="line-height:26px">所以可以通过双线性插&#20540;来得到该采样点的像素&#20540;。（这个双线性插&#20540;没太明白，不过python的<br> scipy工具包里有，我的代码里是直接round函数取整的，大家可以自己加上。）</span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:26px"></span></span></span></span></p>
<p></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:26px">此时我们发现，这个圆形的算子很坑爹啊，万一图片一旋转，同一个点的LBP&#20540;就会改变了，很不合理啊，所以大神们用了一种很简单的方法实现了旋转不变性。</span></span></span></span></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:26px"><img src="http://img.blog.csdn.net/20150414201643662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></span></span></p>
<p></p>
<p><span style="color:rgb(51,51,51)"><span style="line-height:19.0909080505371px"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="line-height:26px">如上图所示，原本一开始我们算的这个点的LBP&#20540;是11100001 = 225，这时候我们开始旋转，可以看到每一个情况都旋转到了，我们取这些情况中的最小&#20540;，也就是15，作为这个点的LBP&#20540;，这样不管图片怎么旋转，这个点的LBP&#20540;都会是15，也就是旋转不变性。</span></span></span></span></p>
<h3 id="2-LBP等价模式"><span style="line-height:19.0909080505371px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(255,102,102)">2.</span><span style="color:rgb(51,0,51)"><span style="color:rgb(51,51,51); line-height:26px">LBP等价模式</span></span></span></span></h3><p><span style="line-height:19.0909080505371px; white-space:pre"><span style="color:rgb(51,0,51)"><span style="color:rgb(51,51,51); line-height:26px"></span></span></span></p>
<p><span style="background-color:inherit"><span style="background-color:inherit"><span style="color:rgb(51,0,51); background-color:inherit"><span style="color:rgb(51,51,51); background-color:inherit"><span style="font-family:'Microsoft YaHei'; font-size:14px">这一点的原理是我最没明白的，等到我看透Face<br> Recognition with Lo cal Binary Patterns这篇论文的时候我会加上这一点内容，现在先把人家博文上的解释加上。</span></span></span></span></span></p>
<p><span style="background-color:inherit"><span style="background-color:inherit"><span style="color:rgb(255,0,0); background-color:inherit"><span style="font-family:'Microsoft YaHei'; font-size:14px">一个LBP算子可以产生不同的二进制模式，对于半径为R的圆形区域内含有P个采样点的LBP算子将会产生2^P种模式。很显然，随着邻域集内采样点数的增加，二进制模式的种类是急剧增加的。例如：5×5邻域内20个采样点，有220＝1,048,576种二进制模式。如此多的二&#20540;模式无论对于纹理的提取还是对于纹理的识别、分类及信息的存取都是不利的。同时，过多的模式种类对于纹理的表达是不利的。例如，将LBP算子用于纹理分类或人脸识别时，常采用LBP模式的统计直方图来表达图像的信息，而较多的模式种类将使得数据量过大，且直方图过于稀疏。因此，需要对原始的LBP模式进行降维，使得数据量减少的情况下能最好的代表图像的信息。</span></span></span></span></p>
<p>为了解决二进制模式过多的问题，提高统计性，Ojala提出了采用一种“等价模式”（Uniform Pattern）来对LBP算子的模式种类进行降维。Ojala等认为，在实际图像中，绝大多数LBP模式最多只包含两次从1到0或从0到1的跳变。因此，Ojala将“等价模式”定义为：当某个LBP所对应的循环二进制数从0到1或从1到0最多有两次跳变时，该LBP所对应的二进制就称为一个等价模式类。如00000000（0次跳变），00000111（只含一次从0到1的跳变），10001111（先由1跳到0，再由0跳到1，共两次跳变）都是等价模式类。除等价模式类以外的模式都归为另一类，称为混合模式类，例如10010111（共四次跳变）。</p>
<p><span style="color:rgb(255,0,0); background-color:inherit"><span style="font-family:'Microsoft YaHei'; font-size:14px">通过这样的改进，二进制模式的种类大大减少，而不会丢失任何信息。模式数量由原来的2^P种减少为 P ( P-1)&#43;2种，其中P表示邻域集内的采样点数。对于3×3邻域内8个采样点来说，二进制模式由原始的256种减少为58种，这使得特征向量的维数更少，并且可以减少高频噪声带来的影响。</span></span></p>
<div style="widows:auto; line-height:21px"><span style="font-family:'Microsoft YaHei'; font-size:14px">&nbsp; &nbsp; 这里我不明白的点是：</span></div><br><div style="widows:auto; line-height:21px"><span style="font-family:'Microsoft YaHei'; font-size:14px">&nbsp; &nbsp; 1. 这个等价模式类还好，但是根据这个说法整个不就是两种模式了吗，一种是等价模式，一种是混合模式，那又怎么会出现 P ( P-1)&#43;2种模式呢？说白了还是这个式子是怎么推出来的不清楚。</span></div><br><div style="widows:auto; line-height:21px"><span style="font-family:'Microsoft YaHei'; font-size:14px">&nbsp; &nbsp; 2. 这个模式的减少意思是这个LBP&#20540;从2^P种减少到P ( P-1)&#43;2种吗？换句话说，00000000，00000111的模式一样，那影响他的LBP&#20540;吗？</span></div><br><div style="widows:auto; line-height:21px"><span style="font-family:'Microsoft YaHei'; font-size:14px">&nbsp; &nbsp; 因为这些疑问，所以在我代码中也没有这部分内容，请见谅。</span></div>

<p><span style="font-family:'Microsoft YaHei'; font-size:14px"></span></p>
<p><span style="white-space:pre"></span></p>
<h3 id="3-&nbsp;LBP特征匹配"><span style="font-family:'Microsoft YaHei'; font-size:14px">3.&nbsp;<span style="color:rgb(51,51,51); line-height:26px">LBP特征匹配</span></span></h3><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(51,51,51); line-height:26px"><span style="white-space:pre">如果将以上得到的LBP&#20540;直接用于人脸识别，其实和不提取LBP特征没什么区别，会造成计算量准确率等一系列问题。将一副人脸图像分为7x7的子区</span></span></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(51,51,51); line-height:26px"><span style="white-space:pre"><br><br></span></span></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(51,51,51); line-height:26px"><span style="white-space:pre">域（如下图），并在子区域内根据LBP&#20540;统计其直方图，以直方图作为其判别特征。这样做的好处是在一定范围内避免图像没完全对准的情况，</span></span></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(51,51,51); line-height:26px"><span style="white-space:pre">同时也对LBP特征做了降维处理。</span></span></span></div><br><div style="text-align:center"><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"><img src="http://img.blog.csdn.net/20150414200606916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre">其实</span>在上面提到的那篇论文里，分区的意义还在于我们可以根据不同的子区域给予不同的权重，比如说我们认为鼻子的权重大于边缘子区域对于整个图片的权重。权重的意思也就是这个部分对于匹配时整个图片的意义。</span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>我们根据LBP&#20540;统计直方图，上面提到的LBP&#20540;有2^8=256种，其实也就是一个灰度图的直方图统计过程。只要我们把LBP&#20540;看做一个新的像素&#20540;。</span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="white-space:pre"></span>在我的代码中<span style="color:rgb(51,51,51); line-height:26px">判别其相&#20284;性的方法是，假设已知人脸直方图为</span><span style="color:rgb(51,51,51); line-height:26px">M，训练人脸的直方图是N1，N2，，，Ni<br> 我计算他们每个子区域内的直方图的差，再取平方获得最后的相&#20284;&#20540;，对比所有的相&#20284;&#20540;，取最小的。（这样很简单。。）</span></span></div><br><div><span style="font-family:'Microsoft YaHei'"><span style="font-size:14px"><span style="color:rgb(51,51,51); line-height:26px"><span style="white-space:pre"></span>真正判断相&#20284;性的方法有：</span></span></span></div><br><div><span style="color:rgb(51,51,51); line-height:26px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150414201420763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></div><br><div><span style="color:rgb(51,51,51); line-height:26px; white-space:pre"><span style="font-family:'Microsoft YaHei'; font-size:14px"><img src="http://img.blog.csdn.net/20150414201502009?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNjY0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></span></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><span style="color:rgb(51,51,51); line-height:26px; white-space:pre">大家可以</span>去google一下，然后自己实现。</span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><br><br></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px"><br><br></span></div><br><div><span style="font-family:'Microsoft YaHei'; font-size:14px">代码（这里说一句，虽然一般都是说LBP算法对于光照不敏感，但是大家看实验结果，带light的准确率都很低，，应该是我的代码问题，希望有大神如果愿意的话能告诉我哪里的问题）：</span><pre name="code" class="python">#coding:utf-8<br>#——————————————–<br>#   作用：LBP人脸识别算法实现<br>#   日期：2015年4月11日<br>#   算法链接：<a href="http://blog.csdn.net/feirose/article/details/39552977" target="_blank" rel="external">http://blog.csdn.net/feirose/article/details/39552977</a><br>#           <a href="http://blog.csdn.net/zouxy09/article/details/7929531" target="_blank" rel="external">http://blog.csdn.net/zouxy09/article/details/7929531</a><br>#   实验结果：accuracy of centerlight is 0.333333<br>#             accuracy of glasses is 0.933333<br>#             accuracy of happy is 0.933333<br>#             accuracy of leftlight is 0.266667<br>#             accuracy of noglasses is 0.933333<br>#             accuracy of rightlight is 0.133333<br>#             accuracy of sad is 0.933333<br>#             accuracy of sleepy is 0.933333<br>#             accuracy of surprised is 0.866667<br>#             accuracy of wink is 0.800000<br>#   执行时间：494.759438799s<br>#——————————————–<br>from numpy import <em><br>from numpy import linalg as la<br>import cv2<br>import os<br>import math<br><br># 为了让LBP具有旋转不变性，将二进制串进行旋转。<br># 假设一开始得到的LBP特征为10010000，那么将这个二进制特征，<br># 按照顺时针方向旋转，可以转化为00001001的形式，这样得到的LBP值是最小的。<br># 无论图像怎么旋转，对点提取的二进制特征的最小值是不变的，<br># 用最小值作为提取的LBP特征，这样LBP就是旋转不变的了。<br>def minBinary(pixel):<br>    length = len(pixel)<br>    zero = &#39;&#39;<br>    for i in range(length)[::-1]:<br>        if pixel[i] == &#39;0&#39;:<br>            pixel = pixel[:i]<br>            zero += &#39;0&#39;<br>        else:<br>            return zero + pixel<br>    if len(pixel) == 0:<br>        return &#39;0&#39;<br><br># 加载图像<br>def loadImageSet(add):<br>    FaceMat = mat(zeros((15,98</em>116)))<br>    j =0<br>    for i in os.listdir(add):<br>        if i.split(&#39;.&#39;)[1] == &#39;noglasses&#39;:<br>            try:<br>                img = cv2.imread(add+i,0)<br>                # cv2.imwrite(str(i)+&#39;.jpg&#39;,img)<br>            except:<br>                print &#39;load %s failed&#39;%i<br>            FaceMat[j,:] = mat(img).flatten()<br>            j += 1<br>    return FaceMat<br><br># 算法主过程<br>def LBP(FaceMat,R = 2,P = 8):<br>    Region8_x=[-1,0,1,1,1,0,-1,-1]<br>    Region8_y=[-1,-1,-1,0,1,1,1,0]<br>    pi = math.pi<br>    LBPoperator = mat(zeros(shape(FaceMat)))<br>    for i in range(shape(FaceMat)[1]):<br>        # 对每一个图像进行处理<br>        face = FaceMat[:,i].reshape(116,98)<br>        W,H = shape(face)<br>        tempface = mat(zeros((W,H)))<br>        for x in xrange(R,W-R):<br>            for y in xrange(R,H-R):<br>                repixel = &#39;&#39;<br>                pixel=int(face[x,y])<br>                #　圆形LBP算子<br>                for p in [2,1,0,7,6,5,4,3]:<br>                    p = float(p)<br>                    xp = x + R<em> cos(2</em>pi<em>(p/P))<br>                    yp = y - R</em> sin(2<em>pi</em>(p/P))<br>                    if face[xp,yp]&gt;pixel:<br>                        repixel += &#39;1&#39;<br>                    else:<br>                        repixel += &#39;0&#39;<br>                # minBinary保持LBP算子旋转不变<br>                tempface[x,y] = int(minBinary(repixel),base=2)<br>        LBPoperator[:,i] = tempface.flatten().T<br>        # cv2.imwrite(str(i)+&#39;hh.jpg&#39;,array(tempface,uint8))<br>    return LBPoperator<br><br>    # judgeImg:未知判断图像<br>    # LBPoperator:实验图像的LBP算子<br>    # exHistograms:实验图像的直方图分布<br>def judgeFace(judgeImg,LBPoperator,exHistograms):<br>    judgeImg = judgeImg.T<br>    ImgLBPope = LBP(judgeImg)<br>    #  把图片分为7<em>4份 , calHistogram返回的直方图矩阵有28个小矩阵内的直方图<br>    judgeHistogram = calHistogram(ImgLBPope)<br>    minIndex = 0<br>    minVals = inf<br><br>    for  i in range(shape(LBPoperator)[1]):<br>        exHistogram = exHistograms[:,i]<br>        diff = (array(exHistogram-judgeHistogram)**2).sum()<br>        if diff&lt;minVals:<br>            minIndex = i<br>            minVals = diff<br>    return minIndex<br><br># 统计直方图<br>def calHistogram(ImgLBPope):<br>    Img = ImgLBPope.reshape(116,98)<br>    W,H = shape(Img)<br>    # 把图片分为7</em>4份<br>    Histogram = mat(zeros((256,7<em>4)))<br>    maskx,masky = W/4,H/7<br>    for i in range(4):<br>        for j in range(7):<br>            # 使用掩膜opencv来获得子矩阵直方图<br>            mask = zeros(shape(Img), uint8)<br>            mask[i</em>maskx: (i+1)<em>maskx,j</em>masky :(j+1)<em>masky] = 255<br>            hist = cv2.calcHist([array(Img,uint8)],[0],mask,[ 256],[0,256])<br>            Histogram[:,(i+1)</em>(j+1)-1] = mat(hist).flatten().T<br>    return Histogram.flatten().T<br><br>def runLBP():<br>    # 加载图像<br>    FaceMat = loadImageSet(&#39;D:\python/face recongnition\YALE\YALE\unpadded/&#39;).T<br><br>    LBPoperator = LBP(FaceMat) # 获得实验图像LBP算子<br><br>    # 获得实验图像的直方图分布，这里计算是为了可以多次使用<br>    exHistograms = mat(zeros((256<em>4</em>7,shape(LBPoperator)[1])))<br>    for i in range(shape(LBPoperator)[1]):<br>        exHistogram = calHistogram(LBPoperator[:,i])<br>        exHistograms[:,i] = exHistogram<br><br>    #　下面的代码都是根据我的这个数据库来的，就是为了验证算法准确性，如果大家改了实例，请更改下面的代码<br>    nameList = [&#39;01&#39;,&#39;02&#39;,&#39;03&#39;,&#39;04&#39;,&#39;05&#39;,&#39;06&#39;,&#39;07&#39;,&#39;08&#39;,&#39;09&#39;,&#39;10&#39;,&#39;11&#39;,&#39;12&#39;,&#39;13&#39;,&#39;14&#39;,&#39;15&#39;]<br>    characteristic = [&#39;centerlight&#39;,&#39;glasses&#39;,&#39;happy&#39;,&#39;normal&#39;,&#39;leftlight&#39;,&#39;noglasses&#39;,&#39;rightlight&#39;,&#39;sad&#39;,&#39;sleepy&#39;,&#39;surprised&#39;,&#39;wink&#39;]<br>    for c in characteristic:<br>        count = 0<br>        for i in range(len(nameList)):<br>            # 这里的loadname就是我们要识别的未知人脸图，我们通过15张未知人脸找出的对应训练人脸进行对比来求出正确率<br>            loadname = &#39;D:\python/face recongnition\YALE\YALE\unpadded\subject&#39;+nameList[i]+&#39;.&#39;+c+&#39;.pgm&#39;<br>            judgeImg = cv2.imread(loadname,0)<br>            if judgeFace(mat(judgeImg).flatten(),LBPoperator,exHistograms)+1 == int(nameList[i]):<br>                count += 1<br>        print &#39;accuracy of %s is %f&#39;%(c, float(count)/len(nameList))  # 求出正确率<br><br>if <strong>name</strong> == &#39;<strong>main</strong>&#39;:<br>    # 测试这个算法的运行时间<br>    from timeit import Timer<br>    t1=Timer(&quot;runLBP()&quot;,&quot;from <strong>main</strong> import runLBP&quot;)<br>    print t1.timeit(1)<br>    </pre></div><br><div><br><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<p><span style="font-family:'Microsoft YaHei'; font-size:14px">上一次我们说了<a href="http://blog.csdn.net/u010006643/article/details/44978755" tar]]>
    </summary>
    
  </entry>
  
</feed>
